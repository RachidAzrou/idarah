var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  announcements: () => announcements,
  announcementsRelations: () => announcementsRelations,
  bankStatements: () => bankStatements,
  bankStatementsRelations: () => bankStatementsRelations,
  bankTransactions: () => bankTransactions,
  bankTransactionsRelations: () => bankTransactionsRelations,
  boardMembers: () => boardMembers,
  boardMembersRelations: () => boardMembersRelations,
  boardRoleEnum: () => boardRoleEnum,
  boardStatusEnum: () => boardStatusEnum,
  boardTerms: () => boardTerms,
  boardTermsRelations: () => boardTermsRelations,
  cardMeta: () => cardMeta,
  cardMetaRelations: () => cardMetaRelations,
  cardStatusEnum: () => cardStatusEnum,
  cardVerifyResponseSchema: () => cardVerifyResponseSchema,
  companyTypeEnum: () => companyTypeEnum,
  emailCampaigns: () => emailCampaigns,
  emailCampaignsRelations: () => emailCampaignsRelations,
  emailKindEnum: () => emailKindEnum,
  emailMessages: () => emailMessages,
  emailMessagesRelations: () => emailMessagesRelations,
  emailSegments: () => emailSegments,
  emailSegmentsRelations: () => emailSegmentsRelations,
  emailStatusEnum: () => emailStatusEnum,
  emailSuppresses: () => emailSuppresses,
  emailSuppressesRelations: () => emailSuppressesRelations,
  emailTemplates: () => emailTemplates,
  emailTemplatesRelations: () => emailTemplatesRelations,
  expenseCategories: () => expenseCategories,
  expenseCategoriesRelations: () => expenseCategoriesRelations,
  feeStatusEnum: () => feeStatusEnum,
  genderEnum: () => genderEnum,
  insertAnnouncementSchema: () => insertAnnouncementSchema,
  insertBankStatementSchema: () => insertBankStatementSchema,
  insertBankTransactionSchema: () => insertBankTransactionSchema,
  insertBoardMemberSchema: () => insertBoardMemberSchema,
  insertBoardTermSchema: () => insertBoardTermSchema,
  insertCardMetaSchema: () => insertCardMetaSchema,
  insertEmailCampaignSchema: () => insertEmailCampaignSchema,
  insertEmailMessageSchema: () => insertEmailMessageSchema,
  insertEmailSegmentSchema: () => insertEmailSegmentSchema,
  insertEmailSuppressSchema: () => insertEmailSuppressSchema,
  insertEmailTemplateSchema: () => insertEmailTemplateSchema,
  insertExpenseCategorySchema: () => insertExpenseCategorySchema,
  insertMandateSchema: () => insertMandateSchema,
  insertMatchRuleSchema: () => insertMatchRuleSchema,
  insertMemberFinancialSettingsSchema: () => insertMemberFinancialSettingsSchema,
  insertMemberPermissionsSchema: () => insertMemberPermissionsSchema,
  insertMemberSchema: () => insertMemberSchema,
  insertMembershipFeeSchema: () => insertMembershipFeeSchema,
  insertNotificationSchema: () => insertNotificationSchema,
  insertPublicScreenSchema: () => insertPublicScreenSchema,
  insertRuleOutcomeSchema: () => insertRuleOutcomeSchema,
  insertRuleOverrideSchema: () => insertRuleOverrideSchema,
  insertRuleSchema: () => insertRuleSchema,
  insertSepaExportSchema: () => insertSepaExportSchema,
  insertTenantSchema: () => insertTenantSchema,
  insertTransactionSchema: () => insertTransactionSchema,
  insertUserSchema: () => insertUserSchema,
  insertVendorSchema: () => insertVendorSchema,
  mandates: () => mandates,
  mandatesRelations: () => mandatesRelations,
  matchRules: () => matchRules,
  matchRulesRelations: () => matchRulesRelations,
  memberCategoryEnum: () => memberCategoryEnum,
  memberFinancialSettings: () => memberFinancialSettings,
  memberFinancialSettingsRelations: () => memberFinancialSettingsRelations,
  memberPermissions: () => memberPermissions,
  memberPermissionsRelations: () => memberPermissionsRelations,
  members: () => members,
  membersRelations: () => membersRelations,
  membershipFees: () => membershipFees,
  membershipFeesRelations: () => membershipFeesRelations,
  notifications: () => notifications,
  notificationsRelations: () => notificationsRelations,
  paymentMethodEnum: () => paymentMethodEnum,
  paymentTermEnum: () => paymentTermEnum,
  publicScreens: () => publicScreens,
  publicScreensRelations: () => publicScreensRelations,
  recipientStatusEnum: () => recipientStatusEnum,
  reconcileStatusEnum: () => reconcileStatusEnum,
  roleEnum: () => roleEnum,
  ruleOutcomes: () => ruleOutcomes,
  ruleOutcomesRelations: () => ruleOutcomesRelations,
  ruleOverrides: () => ruleOverrides,
  ruleScopeEnum: () => ruleScopeEnum,
  rules: () => rules,
  rulesRelations: () => rulesRelations,
  screenTypeEnum: () => screenTypeEnum,
  sepaExports: () => sepaExports,
  sepaExportsRelations: () => sepaExportsRelations,
  statementTypeEnum: () => statementTypeEnum,
  suppressReasonEnum: () => suppressReasonEnum,
  tenants: () => tenants,
  tenantsRelations: () => tenantsRelations,
  transactions: () => transactions,
  transactionsRelations: () => transactionsRelations,
  txnSideEnum: () => txnSideEnum,
  users: () => users,
  usersRelations: () => usersRelations,
  vendors: () => vendors,
  vendorsRelations: () => vendorsRelations
});
import { sql, relations } from "drizzle-orm";
import {
  pgTable,
  text,
  varchar,
  timestamp,
  boolean,
  decimal,
  integer,
  json,
  pgEnum
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var roleEnum, genderEnum, memberCategoryEnum, paymentTermEnum, paymentMethodEnum, feeStatusEnum, screenTypeEnum, cardStatusEnum, ruleScopeEnum, companyTypeEnum, reconcileStatusEnum, statementTypeEnum, txnSideEnum, boardRoleEnum, boardStatusEnum, emailKindEnum, emailStatusEnum, recipientStatusEnum, suppressReasonEnum, tenants, users, members, memberFinancialSettings, memberPermissions, mandates, membershipFees, transactions, rules, ruleOutcomes, ruleOverrides, publicScreens, announcements, cardMeta, notifications, boardMembers, boardTerms, sepaExports, bankStatements, bankTransactions, expenseCategories, vendors, matchRules, emailTemplates, emailSegments, emailCampaigns, emailMessages, emailSuppresses, tenantsRelations, usersRelations, membersRelations, memberFinancialSettingsRelations, memberPermissionsRelations, mandatesRelations, membershipFeesRelations, transactionsRelations, rulesRelations, ruleOutcomesRelations, publicScreensRelations, announcementsRelations, cardMetaRelations, notificationsRelations, boardMembersRelations, boardTermsRelations, sepaExportsRelations, bankStatementsRelations, bankTransactionsRelations, expenseCategoriesRelations, vendorsRelations, matchRulesRelations, emailTemplatesRelations, emailSegmentsRelations, emailCampaignsRelations, emailMessagesRelations, emailSuppressesRelations, insertTenantSchema, insertUserSchema, insertMemberSchema, insertMemberFinancialSettingsSchema, insertMemberPermissionsSchema, insertMandateSchema, insertMembershipFeeSchema, insertTransactionSchema, insertRuleSchema, insertRuleOutcomeSchema, insertRuleOverrideSchema, insertPublicScreenSchema, insertAnnouncementSchema, insertCardMetaSchema, cardVerifyResponseSchema, insertNotificationSchema, insertSepaExportSchema, insertBankStatementSchema, insertBankTransactionSchema, insertExpenseCategorySchema, insertVendorSchema, insertMatchRuleSchema, insertBoardMemberSchema, insertBoardTermSchema, insertEmailTemplateSchema, insertEmailSegmentSchema, insertEmailCampaignSchema, insertEmailMessageSchema, insertEmailSuppressSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    roleEnum = pgEnum("role", ["SUPERADMIN", "BEHEERDER", "MEDEWERKER"]);
    genderEnum = pgEnum("gender", ["M", "V"]);
    memberCategoryEnum = pgEnum("member_category", ["STUDENT", "STANDAARD", "SENIOR"]);
    paymentTermEnum = pgEnum("payment_term", ["MONTHLY", "YEARLY"]);
    paymentMethodEnum = pgEnum("payment_method", ["SEPA", "OVERSCHRIJVING", "BANCONTACT", "CASH"]);
    feeStatusEnum = pgEnum("fee_status", ["OPEN", "PAID", "OVERDUE"]);
    screenTypeEnum = pgEnum("screen_type", ["LEDENLIJST", "MEDEDELINGEN", "MULTIMEDIA"]);
    cardStatusEnum = pgEnum("card_status", ["ACTUEEL", "NIET_ACTUEEL", "VERLOPEN"]);
    ruleScopeEnum = pgEnum("rule_scope", ["STEMRECHT", "VERKIESBAAR"]);
    companyTypeEnum = pgEnum("company_type", ["VZW", "BVBA", "NV", "VOF", "EENMANSZAAK", "CVBA", "SE", "ANDERE"]);
    reconcileStatusEnum = pgEnum("reconcile_status", ["ONTVANGEN", "VOORGESTELD", "GEDEELTELIJK_GEMATCHT", "GEMATCHT", "AFGEKEURD", "GEBOEKT"]);
    statementTypeEnum = pgEnum("statement_type", ["BANK", "CSV", "MT940", "CODA"]);
    txnSideEnum = pgEnum("txn_side", ["CREDIT", "DEBET"]);
    boardRoleEnum = pgEnum("board_role", ["VOORZITTER", "VICE_VOORZITTER", "SECRETARIS", "PENNINGMEESTER", "BESTUURSLID", "ANDERS"]);
    boardStatusEnum = pgEnum("board_status", ["ACTIEF", "INACTIEF"]);
    emailKindEnum = pgEnum("email_kind", ["TRANSACTIONEEL", "MARKETING"]);
    emailStatusEnum = pgEnum("email_status", ["DRAFT", "QUEUED", "SENDING", "SENT", "PARTIAL", "FAILED", "CANCELLED"]);
    recipientStatusEnum = pgEnum("recipient_status", ["QUEUED", "SENT", "FAILED", "OPENED", "CLICKED", "UNSUBSCRIBED"]);
    suppressReasonEnum = pgEnum("suppress_reason", ["UNSUB_REQUEST", "BOUNCE", "SPAM_COMPLAINT", "MANUAL"]);
    tenants = pgTable("tenants", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      slug: text("slug").notNull().unique(),
      street: text("street"),
      number: text("number"),
      postalCode: text("postal_code"),
      city: text("city"),
      country: text("country").default("Belgi\xEB"),
      email: text("email"),
      phone: text("phone"),
      website: text("website"),
      companyNumber: text("company_number"),
      companyType: companyTypeEnum("company_type"),
      logoUrl: text("logo_url"),
      primaryColor: text("primary_color"),
      // Membership fee settings
      studentFee: decimal("student_fee", { precision: 10, scale: 2 }).default("15.00"),
      adultFee: decimal("adult_fee", { precision: 10, scale: 2 }).default("25.00"),
      seniorFee: decimal("senior_fee", { precision: 10, scale: 2 }).default("20.00"),
      defaultPaymentTerm: paymentTermEnum("default_payment_term").default("YEARLY"),
      defaultPaymentMethod: paymentMethodEnum("default_payment_method").default("SEPA"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    users = pgTable("users", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      email: text("email").notNull().unique(),
      passwordHash: text("password_hash").notNull(),
      role: roleEnum("role").notNull(),
      active: boolean("active").default(true).notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    members = pgTable("members", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      memberNumber: text("member_number").notNull().unique(),
      firstName: text("first_name").notNull(),
      lastName: text("last_name").notNull(),
      gender: genderEnum("gender").notNull(),
      birthDate: timestamp("birth_date"),
      category: memberCategoryEnum("category").notNull(),
      email: text("email"),
      phone: text("phone"),
      street: text("street"),
      number: text("number"),
      bus: text("bus"),
      postalCode: text("postal_code"),
      city: text("city"),
      country: text("country"),
      active: boolean("active").default(true).notNull(),
      votingRights: boolean("voting_rights").default(false).notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    memberFinancialSettings = pgTable("member_financial_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      memberId: varchar("member_id").notNull().unique(),
      paymentMethod: paymentMethodEnum("payment_method").notNull(),
      paymentTerm: paymentTermEnum("payment_term").notNull(),
      monthlyAmount: decimal("monthly_amount", { precision: 10, scale: 2 }).default("0.00"),
      yearlyAmount: decimal("yearly_amount", { precision: 10, scale: 2 }).default("0.00"),
      billingAnchorAt: timestamp("billing_anchor_at").defaultNow(),
      iban: text("iban")
    });
    memberPermissions = pgTable("member_permissions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      memberId: varchar("member_id").notNull().unique(),
      privacyAgreement: boolean("privacy_agreement").default(false).notNull(),
      photoVideoConsent: boolean("photo_video_consent").default(false).notNull(),
      newsletterSubscription: boolean("newsletter_subscription").default(false).notNull(),
      whatsappList: boolean("whatsapp_list").default(false).notNull(),
      interestedInActiveRole: boolean("interested_in_active_role").default(false).notNull(),
      roleDescription: text("role_description"),
      votingEligible: boolean("voting_eligible").default(false).notNull()
    });
    mandates = pgTable("mandates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      memberId: varchar("member_id").notNull(),
      mandateRef: text("mandate_ref").notNull().unique(),
      signedAt: timestamp("signed_at").notNull(),
      status: text("status").notNull()
      // ACTIVE, REVOKED, PENDING
    });
    membershipFees = pgTable("membership_fees", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      memberId: varchar("member_id").notNull(),
      memberNumber: text("member_number").notNull(),
      memberName: text("member_name").notNull(),
      periodStart: timestamp("period_start").notNull(),
      periodEnd: timestamp("period_end").notNull(),
      amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
      status: feeStatusEnum("status").default("OPEN").notNull(),
      method: paymentMethodEnum("method"),
      sepaEligible: boolean("sepa_eligible").default(false).notNull(),
      paidAt: timestamp("paid_at"),
      sepaBatchId: varchar("sepa_batch_id"),
      note: text("note"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => ({
      // Unique constraint on tenant, member, and period
      uniquePeriod: sql`UNIQUE (${table.tenantId}, ${table.memberId}, ${table.periodStart}, ${table.periodEnd})`
    }));
    transactions = pgTable("transactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      memberId: varchar("member_id"),
      type: text("type").notNull(),
      // INCOME / EXPENSE
      category: text("category").notNull(),
      amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
      date: timestamp("date").notNull(),
      method: paymentMethodEnum("method"),
      description: text("description"),
      relatedFeeId: varchar("related_fee_id")
    });
    rules = pgTable("rules", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      description: text("description"),
      scope: ruleScopeEnum("scope").notNull(),
      parameters: json("parameters").notNull(),
      active: boolean("active").default(true).notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    ruleOutcomes = pgTable("rule_outcomes", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      ruleId: varchar("rule_id").notNull(),
      memberId: varchar("member_id").notNull(),
      eligible: boolean("eligible").notNull(),
      evaluatedAt: timestamp("evaluated_at").defaultNow().notNull()
    });
    ruleOverrides = pgTable("rule_overrides", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      memberId: varchar("member_id").notNull(),
      ruleScope: ruleScopeEnum("rule_scope").notNull(),
      overrideValue: boolean("override_value").notNull(),
      reason: text("reason").notNull(),
      overriddenBy: varchar("overridden_by").notNull(),
      // User ID who made the override
      overriddenAt: timestamp("overridden_at").defaultNow().notNull(),
      active: boolean("active").default(true).notNull()
    });
    publicScreens = pgTable("public_screens", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      type: screenTypeEnum("type").notNull(),
      active: boolean("active").default(true).notNull(),
      config: json("config").notNull(),
      publicToken: text("public_token").notNull().unique(),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    announcements = pgTable("announcements", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      title: text("title").notNull(),
      richText: text("rich_text"),
      mediaUrl: text("media_url"),
      mediaType: text("media_type"),
      validFrom: timestamp("valid_from"),
      validTo: timestamp("valid_to"),
      active: boolean("active").default(true).notNull(),
      screenId: varchar("screen_id"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    cardMeta = pgTable("card_meta", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      memberId: varchar("member_id").notNull().unique(),
      version: integer("version").default(1).notNull(),
      etag: text("etag").notNull(),
      secureToken: text("secure_token").notNull().unique(),
      qrToken: text("qr_token").notNull().unique(),
      status: cardStatusEnum("status").default("ACTUEEL").notNull(),
      validUntil: timestamp("valid_until"),
      lastRenderedAt: timestamp("last_rendered_at").defaultNow().notNull()
    });
    notifications = pgTable("notifications", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      type: text("type").notNull(),
      // finance/system/member
      title: text("title").notNull(),
      body: text("body"),
      isRead: boolean("is_read").default(false).notNull(),
      userId: varchar("user_id"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    boardMembers = pgTable("board_members", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      memberId: varchar("member_id"),
      // link naar Member indien intern
      externalName: text("external_name"),
      // naam indien extern
      email: text("email"),
      phone: text("phone"),
      role: boardRoleEnum("role").notNull(),
      customRole: text("custom_role"),
      // custom role text when role is 'ANDERS'
      status: boardStatusEnum("status").default("ACTIEF").notNull(),
      termStart: timestamp("term_start").notNull(),
      termEnd: timestamp("term_end"),
      responsibilities: text("responsibilities"),
      orderIndex: integer("order_index").default(100).notNull(),
      avatarUrl: text("avatar_url"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    boardTerms = pgTable("board_terms", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      boardMemberId: varchar("board_member_id").notNull(),
      role: boardRoleEnum("role").notNull(),
      start: timestamp("start").notNull(),
      end: timestamp("end"),
      note: text("note"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    sepaExports = pgTable("sepa_exports", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      batchRef: text("batch_ref").notNull().unique(),
      xml: text("xml").notNull(),
      totalAmount: decimal("total_amount", { precision: 12, scale: 2 }).notNull(),
      numTx: integer("num_tx").notNull(),
      status: text("status").notNull(),
      // GENERATED / SUBMITTED
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    bankStatements = pgTable("bank_statements", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      type: statementTypeEnum("type").notNull(),
      sourceName: text("source_name").notNull(),
      importedAt: timestamp("imported_at").defaultNow().notNull(),
      importedById: varchar("imported_by_id"),
      numTx: integer("num_tx").notNull(),
      rawFileUrl: text("raw_file_url")
    });
    bankTransactions = pgTable("bank_transactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      statementId: varchar("statement_id").notNull(),
      bookingDate: timestamp("booking_date").notNull(),
      valueDate: timestamp("value_date"),
      side: txnSideEnum("side").notNull(),
      amount: decimal("amount", { precision: 12, scale: 2 }).notNull(),
      currency: text("currency").default("EUR").notNull(),
      counterparty: text("counterparty"),
      iban: text("iban"),
      description: text("description"),
      ref: text("ref"),
      // end-to-end / mededeling
      status: reconcileStatusEnum("status").default("ONTVANGEN").notNull(),
      categoryId: varchar("category_id"),
      vendorId: varchar("vendor_id"),
      matchedFeeId: varchar("matched_fee_id"),
      matchedMemberId: varchar("matched_member_id"),
      matchScore: integer("match_score"),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    expenseCategories = pgTable("expense_categories", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      code: text("code"),
      color: text("color"),
      active: boolean("active").default(true).notNull()
    });
    vendors = pgTable("vendors", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      iban: text("iban"),
      defaultCategoryId: varchar("default_category_id"),
      active: boolean("active").default(true).notNull()
    });
    matchRules = pgTable("match_rules", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      priority: integer("priority").default(100).notNull(),
      active: boolean("active").default(true).notNull(),
      criteria: json("criteria").notNull(),
      // bv. {contains:["lidgeld"], iban:"BE..", amountToleranceCents:100}
      action: json("action").notNull(),
      // bv. {categoryId:"..", vendorId:"..", linkTo:"FEE|MEMBER"}
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    emailTemplates = pgTable("email_templates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      code: text("code").notNull(),
      kind: emailKindEnum("kind").notNull(),
      subject: text("subject").notNull(),
      bodyHtml: text("body_html"),
      bodyText: text("body_text"),
      content: text("content"),
      // New simplified content field
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => ({
      uniqueCode: sql`UNIQUE (${table.tenantId}, ${table.code})`
    }));
    emailSegments = pgTable("email_segments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      rules: json("rules").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    emailCampaigns = pgTable("email_campaigns", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      name: text("name").notNull(),
      templateId: varchar("template_id").notNull(),
      segmentId: varchar("segment_id"),
      kind: emailKindEnum("kind").notNull(),
      status: emailStatusEnum("status").default("DRAFT").notNull(),
      scheduledAt: timestamp("scheduled_at"),
      startedAt: timestamp("started_at"),
      finishedAt: timestamp("finished_at"),
      createdById: varchar("created_by_id"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    emailMessages = pgTable("email_messages", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      campaignId: varchar("campaign_id"),
      templateId: varchar("template_id").notNull(),
      memberId: varchar("member_id"),
      email: text("email").notNull(),
      subject: text("subject").notNull(),
      bodyHtml: text("body_html").notNull(),
      bodyText: text("body_text"),
      status: recipientStatusEnum("status").default("QUEUED").notNull(),
      lastError: text("last_error"),
      tokens: json("tokens").notNull(),
      retryCount: integer("retry_count").default(0).notNull(),
      sentAt: timestamp("sent_at"),
      openedAt: timestamp("opened_at"),
      clickedAt: timestamp("clicked_at"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    emailSuppresses = pgTable("email_suppresses", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      tenantId: varchar("tenant_id").notNull(),
      email: text("email").notNull(),
      memberId: varchar("member_id"),
      reason: suppressReasonEnum("reason").default("UNSUB_REQUEST").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => ({
      uniqueEmail: sql`UNIQUE (${table.tenantId}, ${table.email})`
    }));
    tenantsRelations = relations(tenants, ({ many }) => ({
      users: many(users),
      members: many(members),
      rules: many(rules),
      screens: many(publicScreens),
      announcements: many(announcements),
      fees: many(membershipFees),
      mandates: many(mandates),
      transactions: many(transactions),
      notifications: many(notifications),
      sepaBatches: many(sepaExports),
      bankStatements: many(bankStatements),
      bankTransactions: many(bankTransactions),
      expenseCategories: many(expenseCategories),
      vendors: many(vendors),
      matchRules: many(matchRules),
      boardMembers: many(boardMembers),
      boardTerms: many(boardTerms),
      emailTemplates: many(emailTemplates),
      emailSegments: many(emailSegments),
      emailCampaigns: many(emailCampaigns),
      emailMessages: many(emailMessages),
      emailSuppresses: many(emailSuppresses)
    }));
    usersRelations = relations(users, ({ one }) => ({
      tenant: one(tenants, {
        fields: [users.tenantId],
        references: [tenants.id]
      })
    }));
    membersRelations = relations(members, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [members.tenantId],
        references: [tenants.id]
      }),
      financialSettings: one(memberFinancialSettings, {
        fields: [members.id],
        references: [memberFinancialSettings.memberId]
      }),
      permissions: one(memberPermissions, {
        fields: [members.id],
        references: [memberPermissions.memberId]
      }),
      card: one(cardMeta),
      fees: many(membershipFees),
      mandates: many(mandates),
      transactions: many(transactions),
      ruleOutcomes: many(ruleOutcomes),
      boardMember: one(boardMembers, {
        fields: [members.id],
        references: [boardMembers.memberId]
      })
    }));
    memberFinancialSettingsRelations = relations(memberFinancialSettings, ({ one }) => ({
      member: one(members, {
        fields: [memberFinancialSettings.memberId],
        references: [members.id]
      })
    }));
    memberPermissionsRelations = relations(memberPermissions, ({ one }) => ({
      member: one(members, {
        fields: [memberPermissions.memberId],
        references: [members.id]
      })
    }));
    mandatesRelations = relations(mandates, ({ one }) => ({
      tenant: one(tenants, {
        fields: [mandates.tenantId],
        references: [tenants.id]
      }),
      member: one(members, {
        fields: [mandates.memberId],
        references: [members.id]
      })
    }));
    membershipFeesRelations = relations(membershipFees, ({ one }) => ({
      tenant: one(tenants, {
        fields: [membershipFees.tenantId],
        references: [tenants.id]
      }),
      member: one(members, {
        fields: [membershipFees.memberId],
        references: [members.id]
      }),
      sepaBatch: one(sepaExports, {
        fields: [membershipFees.sepaBatchId],
        references: [sepaExports.id]
      })
    }));
    transactionsRelations = relations(transactions, ({ one }) => ({
      tenant: one(tenants, {
        fields: [transactions.tenantId],
        references: [tenants.id]
      }),
      member: one(members, {
        fields: [transactions.memberId],
        references: [members.id]
      })
    }));
    rulesRelations = relations(rules, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [rules.tenantId],
        references: [tenants.id]
      }),
      outcomes: many(ruleOutcomes)
    }));
    ruleOutcomesRelations = relations(ruleOutcomes, ({ one }) => ({
      tenant: one(tenants, {
        fields: [ruleOutcomes.tenantId],
        references: [tenants.id]
      }),
      rule: one(rules, {
        fields: [ruleOutcomes.ruleId],
        references: [rules.id]
      }),
      member: one(members, {
        fields: [ruleOutcomes.memberId],
        references: [members.id]
      })
    }));
    publicScreensRelations = relations(publicScreens, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [publicScreens.tenantId],
        references: [tenants.id]
      }),
      announcements: many(announcements)
    }));
    announcementsRelations = relations(announcements, ({ one }) => ({
      tenant: one(tenants, {
        fields: [announcements.tenantId],
        references: [tenants.id]
      }),
      screen: one(publicScreens, {
        fields: [announcements.screenId],
        references: [publicScreens.id]
      })
    }));
    cardMetaRelations = relations(cardMeta, ({ one }) => ({
      tenant: one(tenants, {
        fields: [cardMeta.tenantId],
        references: [tenants.id]
      }),
      member: one(members, {
        fields: [cardMeta.memberId],
        references: [members.id]
      })
    }));
    notificationsRelations = relations(notifications, ({ one }) => ({
      tenant: one(tenants, {
        fields: [notifications.tenantId],
        references: [tenants.id]
      }),
      user: one(users, {
        fields: [notifications.userId],
        references: [users.id]
      })
    }));
    boardMembersRelations = relations(boardMembers, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [boardMembers.tenantId],
        references: [tenants.id]
      }),
      member: one(members, {
        fields: [boardMembers.memberId],
        references: [members.id]
      }),
      terms: many(boardTerms)
    }));
    boardTermsRelations = relations(boardTerms, ({ one }) => ({
      tenant: one(tenants, {
        fields: [boardTerms.tenantId],
        references: [tenants.id]
      }),
      boardMember: one(boardMembers, {
        fields: [boardTerms.boardMemberId],
        references: [boardMembers.id]
      })
    }));
    sepaExportsRelations = relations(sepaExports, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [sepaExports.tenantId],
        references: [tenants.id]
      }),
      fees: many(membershipFees)
    }));
    bankStatementsRelations = relations(bankStatements, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [bankStatements.tenantId],
        references: [tenants.id]
      }),
      importedBy: one(users, {
        fields: [bankStatements.importedById],
        references: [users.id]
      }),
      transactions: many(bankTransactions)
    }));
    bankTransactionsRelations = relations(bankTransactions, ({ one }) => ({
      tenant: one(tenants, {
        fields: [bankTransactions.tenantId],
        references: [tenants.id]
      }),
      statement: one(bankStatements, {
        fields: [bankTransactions.statementId],
        references: [bankStatements.id]
      }),
      category: one(expenseCategories, {
        fields: [bankTransactions.categoryId],
        references: [expenseCategories.id]
      }),
      vendor: one(vendors, {
        fields: [bankTransactions.vendorId],
        references: [vendors.id]
      }),
      matchedFee: one(membershipFees, {
        fields: [bankTransactions.matchedFeeId],
        references: [membershipFees.id]
      }),
      matchedMember: one(members, {
        fields: [bankTransactions.matchedMemberId],
        references: [members.id]
      })
    }));
    expenseCategoriesRelations = relations(expenseCategories, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [expenseCategories.tenantId],
        references: [tenants.id]
      }),
      transactions: many(bankTransactions),
      vendors: many(vendors)
    }));
    vendorsRelations = relations(vendors, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [vendors.tenantId],
        references: [tenants.id]
      }),
      defaultCategory: one(expenseCategories, {
        fields: [vendors.defaultCategoryId],
        references: [expenseCategories.id]
      }),
      transactions: many(bankTransactions)
    }));
    matchRulesRelations = relations(matchRules, ({ one }) => ({
      tenant: one(tenants, {
        fields: [matchRules.tenantId],
        references: [tenants.id]
      })
    }));
    emailTemplatesRelations = relations(emailTemplates, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [emailTemplates.tenantId],
        references: [tenants.id]
      }),
      campaigns: many(emailCampaigns),
      messages: many(emailMessages)
    }));
    emailSegmentsRelations = relations(emailSegments, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [emailSegments.tenantId],
        references: [tenants.id]
      }),
      campaigns: many(emailCampaigns)
    }));
    emailCampaignsRelations = relations(emailCampaigns, ({ one, many }) => ({
      tenant: one(tenants, {
        fields: [emailCampaigns.tenantId],
        references: [tenants.id]
      }),
      template: one(emailTemplates, {
        fields: [emailCampaigns.templateId],
        references: [emailTemplates.id]
      }),
      segment: one(emailSegments, {
        fields: [emailCampaigns.segmentId],
        references: [emailSegments.id]
      }),
      createdBy: one(users, {
        fields: [emailCampaigns.createdById],
        references: [users.id]
      }),
      messages: many(emailMessages)
    }));
    emailMessagesRelations = relations(emailMessages, ({ one }) => ({
      tenant: one(tenants, {
        fields: [emailMessages.tenantId],
        references: [tenants.id]
      }),
      campaign: one(emailCampaigns, {
        fields: [emailMessages.campaignId],
        references: [emailCampaigns.id]
      }),
      template: one(emailTemplates, {
        fields: [emailMessages.templateId],
        references: [emailTemplates.id]
      }),
      member: one(members, {
        fields: [emailMessages.memberId],
        references: [members.id]
      })
    }));
    emailSuppressesRelations = relations(emailSuppresses, ({ one }) => ({
      tenant: one(tenants, {
        fields: [emailSuppresses.tenantId],
        references: [tenants.id]
      }),
      member: one(members, {
        fields: [emailSuppresses.memberId],
        references: [members.id]
      })
    }));
    insertTenantSchema = createInsertSchema(tenants).omit({
      id: true,
      createdAt: true
    });
    insertUserSchema = createInsertSchema(users).omit({
      id: true,
      createdAt: true
    });
    insertMemberSchema = createInsertSchema(members).omit({
      id: true,
      createdAt: true
    });
    insertMemberFinancialSettingsSchema = createInsertSchema(memberFinancialSettings).omit({
      id: true
    });
    insertMemberPermissionsSchema = createInsertSchema(memberPermissions).omit({
      id: true
    });
    insertMandateSchema = createInsertSchema(mandates).omit({
      id: true
    });
    insertMembershipFeeSchema = createInsertSchema(membershipFees).omit({
      id: true,
      createdAt: true
    });
    insertTransactionSchema = createInsertSchema(transactions).omit({
      id: true
    });
    insertRuleSchema = createInsertSchema(rules).omit({
      id: true,
      createdAt: true
    });
    insertRuleOutcomeSchema = createInsertSchema(ruleOutcomes).omit({
      id: true,
      evaluatedAt: true
    });
    insertRuleOverrideSchema = createInsertSchema(ruleOverrides).omit({
      id: true,
      overriddenAt: true
    });
    insertPublicScreenSchema = createInsertSchema(publicScreens).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAnnouncementSchema = createInsertSchema(announcements).omit({
      id: true,
      createdAt: true
    });
    insertCardMetaSchema = createInsertSchema(cardMeta).omit({
      id: true,
      lastRenderedAt: true
    });
    cardVerifyResponseSchema = z.object({
      ok: z.boolean(),
      member: z.object({
        naam: z.string(),
        nummer: z.string()
      }),
      status: z.object({
        actief: z.boolean(),
        betaaldDitJaar: z.boolean(),
        geldigTot: z.string().nullable()
      }),
      tenant: z.object({
        naam: z.string(),
        slug: z.string()
      }),
      ts: z.number()
    });
    insertNotificationSchema = createInsertSchema(notifications).omit({
      id: true,
      createdAt: true
    });
    insertSepaExportSchema = createInsertSchema(sepaExports).omit({
      id: true,
      createdAt: true
    });
    insertBankStatementSchema = createInsertSchema(bankStatements).omit({
      id: true,
      importedAt: true
    });
    insertBankTransactionSchema = createInsertSchema(bankTransactions).omit({
      id: true,
      createdAt: true
    });
    insertExpenseCategorySchema = createInsertSchema(expenseCategories).omit({
      id: true
    });
    insertVendorSchema = createInsertSchema(vendors).omit({
      id: true
    });
    insertMatchRuleSchema = createInsertSchema(matchRules).omit({
      id: true,
      createdAt: true
    });
    insertBoardMemberSchema = createInsertSchema(boardMembers).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      role: z.string().optional().default("BESTUURSLID"),
      // Allow string dates to be converted to Date objects
      termStart: z.union([
        z.date(),
        z.string().transform((val) => new Date(val))
      ]).refine((date) => date instanceof Date && !isNaN(date.getTime()), {
        message: "Ongeldige startdatum"
      }),
      termEnd: z.union([
        z.date(),
        z.string().transform((val) => new Date(val))
      ]).refine((date) => date instanceof Date && !isNaN(date.getTime()), {
        message: "Ongeldige einddatum"
      })
    });
    insertBoardTermSchema = createInsertSchema(boardTerms).omit({
      id: true,
      createdAt: true
    });
    insertEmailTemplateSchema = createInsertSchema(emailTemplates).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertEmailSegmentSchema = createInsertSchema(emailSegments).omit({
      id: true,
      createdAt: true
    });
    insertEmailCampaignSchema = createInsertSchema(emailCampaigns).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertEmailMessageSchema = createInsertSchema(emailMessages).omit({
      id: true,
      createdAt: true
    });
    insertEmailSuppressSchema = createInsertSchema(emailSuppresses).omit({
      id: true,
      createdAt: true
    });
  }
});

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
var pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    neonConfig.webSocketConstructor = ws;
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      max: 20,
      // Maximum 20 connections in pool
      idleTimeoutMillis: 3e4,
      // Close idle connections after 30 seconds
      connectionTimeoutMillis: 2e3
      // Connection timeout 2 seconds
    });
    db = drizzle({ client: pool, schema: schema_exports });
  }
});

// server/cache.ts
var MemoryCache, cache;
var init_cache = __esm({
  "server/cache.ts"() {
    "use strict";
    MemoryCache = class {
      cache = /* @__PURE__ */ new Map();
      DEFAULT_TTL = 3e4;
      // 30 seconds default
      set(key, data, ttl = this.DEFAULT_TTL) {
        this.cache.set(key, {
          data,
          timestamp: Date.now(),
          ttl
        });
      }
      get(key) {
        const entry = this.cache.get(key);
        if (!entry) return null;
        const now = Date.now();
        if (now - entry.timestamp > entry.ttl) {
          this.cache.delete(key);
          return null;
        }
        return entry.data;
      }
      delete(key) {
        this.cache.delete(key);
      }
      deletePattern(pattern) {
        const regex = new RegExp(pattern);
        const keysToDelete = [];
        this.cache.forEach((value, key) => {
          if (regex.test(key)) {
            keysToDelete.push(key);
          }
        });
        keysToDelete.forEach((key) => this.cache.delete(key));
      }
      clear() {
        this.cache.clear();
      }
      // Clean expired entries periodically
      cleanup() {
        const now = Date.now();
        const keysToDelete = [];
        this.cache.forEach((entry, key) => {
          if (now - entry.timestamp > entry.ttl) {
            keysToDelete.push(key);
          }
        });
        keysToDelete.forEach((key) => this.cache.delete(key));
      }
    };
    cache = new MemoryCache();
    setInterval(() => {
      cache.cleanup();
    }, 5 * 60 * 1e3);
  }
});

// server/storage.ts
import { eq, and as and2, desc, sql as sql2 } from "drizzle-orm";
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_db();
    init_cache();
    DatabaseStorage = class {
      // Tenants
      async getTenant(id) {
        const cacheKey = `tenant:${id}`;
        const cached = cache.get(cacheKey);
        if (cached) return cached;
        const [tenant] = await db.select().from(tenants).where(eq(tenants.id, id));
        if (tenant) {
          cache.set(cacheKey, tenant, 6e4);
        }
        return tenant || void 0;
      }
      async getTenantBySlug(slug) {
        const [tenant] = await db.select().from(tenants).where(eq(tenants.slug, slug));
        return tenant || void 0;
      }
      async createTenant(tenant) {
        const [newTenant] = await db.insert(tenants).values(tenant).returning();
        return newTenant;
      }
      async updateTenant(id, tenant) {
        const [updatedTenant] = await db.update(tenants).set(tenant).where(eq(tenants.id, id)).returning();
        return updatedTenant;
      }
      // Users
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user || void 0;
      }
      async getUserByEmail(email) {
        const [user] = await db.select().from(users).where(eq(users.email, email));
        return user || void 0;
      }
      async updateUserPassword(userId, passwordHash) {
        await db.update(users).set({ passwordHash }).where(eq(users.id, userId));
      }
      async getUsersByTenant(tenantId) {
        return await db.select().from(users).where(eq(users.tenantId, tenantId));
      }
      async createUser(user) {
        const [newUser] = await db.insert(users).values(user).returning();
        return newUser;
      }
      async updateUser(id, user) {
        const [updatedUser] = await db.update(users).set(user).where(eq(users.id, id)).returning();
        return updatedUser;
      }
      async deleteUser(id) {
        await db.delete(users).where(eq(users.id, id));
      }
      // Members
      async getMember(id) {
        const [member] = await db.select().from(members).where(eq(members.id, id));
        return member || void 0;
      }
      async getMembersByTenant(tenantId) {
        const cacheKey = `members:tenant:${tenantId}`;
        const cached = cache.get(cacheKey);
        if (cached) return cached;
        const membersData = await db.select().from(members).where(eq(members.tenantId, tenantId)).orderBy(desc(members.createdAt)).limit(1e3);
        cache.set(cacheKey, membersData, 15e3);
        return membersData;
      }
      async getMemberByNumber(tenantId, memberNumber) {
        const normalizedNumber = memberNumber.padStart(4, "0");
        let [member] = await db.select().from(members).where(
          and2(eq(members.tenantId, tenantId), eq(members.memberNumber, normalizedNumber))
        );
        if (!member && memberNumber !== normalizedNumber) {
          [member] = await db.select().from(members).where(
            and2(eq(members.tenantId, tenantId), eq(members.memberNumber, memberNumber))
          );
        }
        if (!member) {
          const memberAsNumber = parseInt(memberNumber);
          if (!isNaN(memberAsNumber)) {
            const variants = [
              memberAsNumber.toString(),
              memberAsNumber.toString().padStart(2, "0"),
              memberAsNumber.toString().padStart(3, "0"),
              memberAsNumber.toString().padStart(4, "0")
            ];
            for (const variant of variants) {
              if (variant !== normalizedNumber && variant !== memberNumber) {
                [member] = await db.select().from(members).where(
                  and2(eq(members.tenantId, tenantId), eq(members.memberNumber, variant))
                );
                if (member) break;
              }
            }
          }
        }
        return member || void 0;
      }
      async createMember(member) {
        const [newMember] = await db.insert(members).values(member).returning();
        cache.deletePattern(`members:tenant:${member.tenantId}`);
        cache.deletePattern(`dashboard:stats:${member.tenantId}`);
        return newMember;
      }
      async updateMember(id, member) {
        const [updatedMember] = await db.update(members).set(member).where(eq(members.id, id)).returning();
        cache.deletePattern(`members:tenant:${updatedMember.tenantId}`);
        cache.deletePattern(`dashboard:stats:${updatedMember.tenantId}`);
        return updatedMember;
      }
      async deleteMember(id) {
        const [member] = await db.select().from(members).where(eq(members.id, id));
        await db.delete(members).where(eq(members.id, id));
        if (member) {
          cache.deletePattern(`members:tenant:${member.tenantId}`);
          cache.deletePattern(`dashboard:stats:${member.tenantId}`);
        }
      }
      // Member Financial Settings
      async getMemberFinancialSettings(memberId) {
        const [settings] = await db.select().from(memberFinancialSettings).where(eq(memberFinancialSettings.memberId, memberId));
        return settings || void 0;
      }
      async createMemberFinancialSettings(settings) {
        const [newSettings] = await db.insert(memberFinancialSettings).values(settings).returning();
        return newSettings;
      }
      async updateMemberFinancialSettings(memberId, settings) {
        const [updatedSettings] = await db.update(memberFinancialSettings).set(settings).where(eq(memberFinancialSettings.memberId, memberId)).returning();
        return updatedSettings;
      }
      // Member Permissions
      async getMemberPermissions(memberId) {
        const [permissions] = await db.select().from(memberPermissions).where(eq(memberPermissions.memberId, memberId));
        return permissions || void 0;
      }
      // Duplicate detection methods
      async getMemberByNameAndAddress(tenantId, firstName, lastName, street, number) {
        const [member] = await db.select().from(members).where(
          and2(
            eq(members.tenantId, tenantId),
            eq(members.firstName, firstName),
            eq(members.lastName, lastName),
            eq(members.street, street),
            eq(members.number, number)
          )
        );
        return member || void 0;
      }
      async getNextAvailableMemberNumber(tenantId, startFrom) {
        const existingNumbers = await db.select({ memberNumber: members.memberNumber }).from(members).where(eq(members.tenantId, tenantId));
        const numberSet = new Set(existingNumbers.map((m) => m.memberNumber));
        let baseNumber = startFrom ? parseInt(startFrom) : 1;
        while (numberSet.has(baseNumber.toString().padStart(4, "0"))) {
          baseNumber++;
        }
        return baseNumber.toString().padStart(4, "0");
      }
      async createMemberPermissions(permissions) {
        const [newPermissions] = await db.insert(memberPermissions).values(permissions).returning();
        return newPermissions;
      }
      async updateMemberPermissions(memberId, permissions) {
        const [updatedPermissions] = await db.update(memberPermissions).set(permissions).where(eq(memberPermissions.memberId, memberId)).returning();
        return updatedPermissions;
      }
      // Membership Fees
      async getMembershipFee(id) {
        const [fee] = await db.select().from(membershipFees).where(eq(membershipFees.id, id));
        return fee || void 0;
      }
      async getMembershipFeesByTenant(tenantId) {
        return await db.select({
          ...membershipFees,
          memberFirstName: members.firstName,
          memberLastName: members.lastName
        }).from(membershipFees).innerJoin(members, eq(membershipFees.memberId, members.id)).where(eq(membershipFees.tenantId, tenantId)).orderBy(desc(membershipFees.createdAt)).limit(2e3);
      }
      async getMembershipFeesByMember(memberId) {
        return await db.select().from(membershipFees).where(eq(membershipFees.memberId, memberId)).orderBy(desc(membershipFees.periodStart));
      }
      async createMembershipFee(fee) {
        const [newFee] = await db.insert(membershipFees).values(fee).returning();
        cache.deletePattern(`dashboard:stats:${fee.tenantId}`);
        return newFee;
      }
      async updateMembershipFee(id, fee) {
        const [updatedFee] = await db.update(membershipFees).set(fee).where(eq(membershipFees.id, id)).returning();
        if (updatedFee.tenantId) {
          cache.deletePattern(`dashboard:stats:${updatedFee.tenantId}`);
        }
        return updatedFee;
      }
      async deleteMembershipFee(id, tenantId) {
        await db.delete(membershipFees).where(and2(eq(membershipFees.id, id), eq(membershipFees.tenantId, tenantId)));
        cache.deletePattern(`dashboard:stats:${tenantId}`);
      }
      // Transactions
      async getTransactionsByTenant(tenantId) {
        const result = await db.execute(sql2`
      SELECT 
        t.id,
        t.tenant_id as "tenantId",
        t.member_id as "memberId", 
        t.type,
        t.category,
        t.amount,
        t.date,
        t.method,
        t.description,
        t.related_fee_id as "relatedFeeId",
        CASE 
          WHEN m.first_name IS NOT NULL AND m.last_name IS NOT NULL 
          THEN CONCAT(m.first_name, ' ', m.last_name)
          WHEN m.first_name IS NOT NULL 
          THEN m.first_name
          WHEN m.last_name IS NOT NULL 
          THEN m.last_name
          ELSE NULL 
        END as "memberName"
      FROM ${transactions} t
      LEFT JOIN ${members} m ON t.member_id = m.id  
      WHERE t.tenant_id = ${tenantId}
      ORDER BY t.date DESC
      LIMIT 1000
    `);
        return result.rows;
      }
      async createTransaction(transaction) {
        const [newTransaction] = await db.insert(transactions).values(transaction).returning();
        return newTransaction;
      }
      async updateTransaction(id, transaction) {
        const [updatedTransaction] = await db.update(transactions).set(transaction).where(eq(transactions.id, id)).returning();
        return updatedTransaction;
      }
      async deleteTransaction(id) {
        await db.delete(transactions).where(eq(transactions.id, id));
      }
      // Rules
      async getRulesByTenant(tenantId) {
        return await db.select().from(rules).where(eq(rules.tenantId, tenantId)).orderBy(desc(rules.createdAt));
      }
      async createRule(rule) {
        const [newRule] = await db.insert(rules).values(rule).returning();
        return newRule;
      }
      async updateRule(id, rule) {
        const [updatedRule] = await db.update(rules).set(rule).where(eq(rules.id, id)).returning();
        return updatedRule;
      }
      async deleteRule(id) {
        await db.delete(rules).where(eq(rules.id, id));
      }
      // Rule Outcomes
      async getRuleOutcomesByMember(memberId) {
        return await db.select().from(ruleOutcomes).where(eq(ruleOutcomes.memberId, memberId)).orderBy(desc(ruleOutcomes.evaluatedAt));
      }
      async createRuleOutcome(outcome) {
        const [newOutcome] = await db.insert(ruleOutcomes).values(outcome).returning();
        return newOutcome;
      }
      // Public Screens
      async getPublicScreensByTenant(tenantId) {
        return await db.select().from(publicScreens).where(eq(publicScreens.tenantId, tenantId)).orderBy(desc(publicScreens.createdAt));
      }
      async getPublicScreenByToken(token) {
        const [screen] = await db.select().from(publicScreens).where(eq(publicScreens.publicToken, token));
        return screen || void 0;
      }
      async createPublicScreen(screen) {
        const [newScreen] = await db.insert(publicScreens).values(screen).returning();
        return newScreen;
      }
      async updatePublicScreen(id, screen) {
        const [updatedScreen] = await db.update(publicScreens).set(screen).where(eq(publicScreens.id, id)).returning();
        return updatedScreen;
      }
      async deletePublicScreen(id) {
        await db.delete(publicScreens).where(eq(publicScreens.id, id));
      }
      // Announcements
      async getAnnouncementsByTenant(tenantId) {
        return await db.select().from(announcements).where(eq(announcements.tenantId, tenantId)).orderBy(desc(announcements.createdAt));
      }
      async createAnnouncement(announcement) {
        const [newAnnouncement] = await db.insert(announcements).values(announcement).returning();
        return newAnnouncement;
      }
      // Card Meta
      async getCardMetaByMember(memberId) {
        const [card] = await db.select().from(cardMeta).where(eq(cardMeta.memberId, memberId));
        return card || void 0;
      }
      async getCardMetaByQrToken(qrToken) {
        const [card] = await db.select().from(cardMeta).where(eq(cardMeta.qrToken, qrToken));
        return card || void 0;
      }
      async createCardMeta(cardMetaData) {
        const [newCard] = await db.insert(cardMeta).values(cardMetaData).returning();
        return newCard;
      }
      async updateCardMeta(id, cardMetaData) {
        const [updatedCard] = await db.update(cardMeta).set(cardMetaData).where(eq(cardMeta.id, id)).returning();
        return updatedCard;
      }
      async getMemberWithCardAndTenant(memberId) {
        const result = await db.select({
          member: members,
          cardMeta,
          tenant: tenants
        }).from(members).innerJoin(cardMeta, eq(members.id, cardMeta.memberId)).innerJoin(tenants, eq(members.tenantId, tenants.id)).where(eq(members.id, memberId));
        if (result.length === 0) return void 0;
        const row = result[0];
        return {
          member: row.member,
          cardMeta: row.cardMeta,
          tenant: row.tenant
        };
      }
      async getAllCardsWithMembers(tenantId) {
        const result = await db.select({
          member: members,
          cardMeta
        }).from(members).leftJoin(cardMeta, eq(members.id, cardMeta.memberId)).where(eq(members.tenantId, tenantId)).orderBy(desc(members.createdAt));
        return result.map((row) => ({
          member: row.member,
          cardMeta: row.cardMeta || null
        }));
      }
      async getCardStats(tenantId) {
        const cacheKey = `card:stats:${tenantId}`;
        const cached = cache.get(cacheKey);
        if (cached) return cached;
        const result = await db.execute(sql2`
      WITH card_stats AS (
        SELECT 
          COUNT(CASE WHEN cm.status = 'ACTUEEL' THEN 1 END) as active_cards,
          COUNT(cm.id) as total_cards,
          COUNT(m.id) as total_members,
          MAX(cm.last_rendered_at) as last_updated
        FROM ${members} m
        LEFT JOIN ${cardMeta} cm ON m.id = cm.member_id
        WHERE m.tenant_id = ${tenantId}
      )
      SELECT 
        active_cards::int,
        total_cards::int,
        total_members::int,
        last_updated
      FROM card_stats
    `);
        const stats = result.rows[0];
        const cardStats = {
          totalActive: parseInt(stats.active_cards) || 0,
          validPercentage: stats.total_members > 0 ? Math.round(parseInt(stats.total_cards) / parseInt(stats.total_members) * 100) : 0,
          lastUpdated: stats.last_updated ? new Date(stats.last_updated) : null
        };
        cache.set(cacheKey, cardStats, 1e4);
        return cardStats;
      }
      // Notifications
      async getNotificationsByTenant(tenantId) {
        return await db.select().from(notifications).where(eq(notifications.tenantId, tenantId)).orderBy(desc(notifications.createdAt));
      }
      async createNotification(notification) {
        const [newNotification] = await db.insert(notifications).values(notification).returning();
        return newNotification;
      }
      // SEPA Exports
      async getSepaExportsByTenant(tenantId) {
        return await db.select().from(sepaExports).where(eq(sepaExports.tenantId, tenantId)).orderBy(desc(sepaExports.createdAt));
      }
      async createSepaExport(sepaExport) {
        const [newExport] = await db.insert(sepaExports).values(sepaExport).returning();
        return newExport;
      }
      // Dashboard stats - Optimized single query with caching
      async getDashboardStats(tenantId) {
        const cacheKey = `dashboard:stats:${tenantId}`;
        const cached = cache.get(cacheKey);
        if (cached) return cached;
        const result = await db.execute(sql2`
      WITH member_stats AS (
        SELECT 
          COUNT(*) as total_members,
          COUNT(CASE WHEN active = true THEN 1 END) as active_members
        FROM ${members} 
        WHERE tenant_id = ${tenantId}
      ),
      fee_stats AS (
        SELECT 
          COALESCE(SUM(CASE WHEN status = 'PAID' THEN amount ELSE 0 END), 0) as total_revenue,
          COALESCE(SUM(CASE WHEN status = 'OPEN' THEN amount ELSE 0 END), 0) as outstanding,
          COALESCE(SUM(CASE 
            WHEN status = 'PAID' 
            AND paid_at >= DATE_TRUNC('month', CURRENT_DATE) 
            AND paid_at < DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month'
            THEN amount ELSE 0 END), 0) as monthly_income
        FROM ${membershipFees} 
        WHERE tenant_id = ${tenantId}
      )
      SELECT 
        m.total_members::int,
        m.active_members::int,
        f.total_revenue::numeric,
        f.outstanding::numeric,
        f.monthly_income::numeric
      FROM member_stats m, fee_stats f
    `);
        const stats = result.rows[0];
        const dashboardStats = {
          totalMembers: parseInt(stats.total_members) || 0,
          activeMembers: parseInt(stats.active_members) || 0,
          totalRevenue: parseFloat(stats.total_revenue) || 0,
          outstanding: parseFloat(stats.outstanding) || 0,
          monthlyIncome: parseFloat(stats.monthly_income) || 0
        };
        cache.set(cacheKey, dashboardStats, 1e4);
        return dashboardStats;
      }
      // Email Templates
      async getEmailTemplatesByTenant(tenantId) {
        return await db.select().from(emailTemplates).where(eq(emailTemplates.tenantId, tenantId)).orderBy(desc(emailTemplates.createdAt));
      }
      async getEmailTemplate(tenantId, id) {
        const [template] = await db.select().from(emailTemplates).where(and2(eq(emailTemplates.tenantId, tenantId), eq(emailTemplates.id, id)));
        return template || void 0;
      }
      async createEmailTemplate(template) {
        const [newTemplate] = await db.insert(emailTemplates).values(template).returning();
        return newTemplate;
      }
      async updateEmailTemplate(tenantId, id, template) {
        const [updatedTemplate] = await db.update(emailTemplates).set({ ...template, updatedAt: /* @__PURE__ */ new Date() }).where(and2(eq(emailTemplates.tenantId, tenantId), eq(emailTemplates.id, id))).returning();
        return updatedTemplate;
      }
      async deleteEmailTemplate(tenantId, id) {
        await db.delete(emailTemplates).where(and2(eq(emailTemplates.tenantId, tenantId), eq(emailTemplates.id, id)));
      }
      // Email Segments
      async getEmailSegmentsByTenant(tenantId) {
        return await db.select().from(emailSegments).where(eq(emailSegments.tenantId, tenantId)).orderBy(desc(emailSegments.createdAt));
      }
      async getEmailSegment(tenantId, id) {
        const [segment] = await db.select().from(emailSegments).where(and2(eq(emailSegments.tenantId, tenantId), eq(emailSegments.id, id)));
        return segment || void 0;
      }
      async createEmailSegment(segment) {
        const [newSegment] = await db.insert(emailSegments).values(segment).returning();
        return newSegment;
      }
      async updateEmailSegment(tenantId, id, segment) {
        const [updatedSegment] = await db.update(emailSegments).set(segment).where(and2(eq(emailSegments.tenantId, tenantId), eq(emailSegments.id, id))).returning();
        return updatedSegment;
      }
      async deleteEmailSegment(tenantId, id) {
        await db.delete(emailSegments).where(and2(eq(emailSegments.tenantId, tenantId), eq(emailSegments.id, id)));
      }
      // Email Campaigns
      async getEmailCampaignsByTenant(tenantId) {
        return await db.select().from(emailCampaigns).where(eq(emailCampaigns.tenantId, tenantId)).orderBy(desc(emailCampaigns.createdAt));
      }
      async getEmailCampaign(tenantId, id) {
        const [campaign] = await db.select().from(emailCampaigns).where(and2(eq(emailCampaigns.tenantId, tenantId), eq(emailCampaigns.id, id)));
        return campaign || void 0;
      }
      async createEmailCampaign(campaign) {
        const [newCampaign] = await db.insert(emailCampaigns).values(campaign).returning();
        return newCampaign;
      }
      async updateEmailCampaign(tenantId, id, campaign) {
        const [updatedCampaign] = await db.update(emailCampaigns).set({ ...campaign, updatedAt: /* @__PURE__ */ new Date() }).where(and2(eq(emailCampaigns.tenantId, tenantId), eq(emailCampaigns.id, id))).returning();
        return updatedCampaign;
      }
      async deleteEmailCampaign(tenantId, id) {
        await db.delete(emailCampaigns).where(and2(eq(emailCampaigns.tenantId, tenantId), eq(emailCampaigns.id, id)));
      }
      // Email Messages
      async getEmailMessagesByTenant(tenantId) {
        return await db.select().from(emailMessages).where(eq(emailMessages.tenantId, tenantId)).orderBy(desc(emailMessages.createdAt));
      }
      async getEmailMessagesByCampaign(tenantId, campaignId) {
        return await db.select().from(emailMessages).where(and2(eq(emailMessages.tenantId, tenantId), eq(emailMessages.campaignId, campaignId))).orderBy(desc(emailMessages.createdAt));
      }
      async createEmailMessage(message) {
        const [newMessage] = await db.insert(emailMessages).values(message).returning();
        return newMessage;
      }
      async updateEmailMessage(id, message) {
        const [updatedMessage] = await db.update(emailMessages).set(message).where(eq(emailMessages.id, id)).returning();
        return updatedMessage;
      }
      // Email Suppresses
      async getEmailSuppressesByTenant(tenantId) {
        return await db.select().from(emailSuppresses).where(eq(emailSuppresses.tenantId, tenantId)).orderBy(desc(emailSuppresses.createdAt));
      }
      async createEmailSuppress(suppress) {
        const [newSuppress] = await db.insert(emailSuppresses).values(suppress).returning();
        return newSuppress;
      }
      async deleteEmailSuppress(tenantId, id) {
        await db.delete(emailSuppresses).where(and2(eq(emailSuppresses.tenantId, tenantId), eq(emailSuppresses.id, id)));
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/services/email.ts
var email_exports = {};
__export(email_exports, {
  EmailService: () => EmailService,
  generatePasswordResetEmail: () => generatePasswordResetEmail,
  sendEmail: () => sendEmail
});
import { MailService } from "@sendgrid/mail";
import { eq as eq2, and as and3, inArray, gte as gte2, lte as lte2, desc as desc2 } from "drizzle-orm";
import Handlebars from "handlebars";
import nodemailer from "nodemailer";
import { randomBytes } from "crypto";
async function sendEmail(params) {
  try {
    if (!process.env.SENDGRID_API_KEY) {
      console.log("SendGrid API key not configured - email would be sent to:", params.to);
      console.log("Subject:", params.subject);
      console.log("Content:", params.text || params.html);
      return true;
    }
    await mailService.send({
      to: params.to,
      from: params.from,
      subject: params.subject,
      text: params.text,
      html: params.html
    });
    console.log("Email sent successfully to:", params.to);
    return true;
  } catch (error) {
    console.error("SendGrid email error:", error);
    return false;
  }
}
function generatePasswordResetEmail(newPassword, userEmail) {
  const subject = "Uw nieuwe wachtwoord - IDARAH Ledenbeheer";
  const text2 = `
Hallo,

U heeft een nieuw wachtwoord aangevraagd voor uw IDARAH Ledenbeheer account.

Uw nieuwe wachtwoord is: ${newPassword}

Log in op het systeem met dit nieuwe wachtwoord. We raden u aan om uw wachtwoord te wijzigen na het inloggen.

Met vriendelijke groet,
Het IDARAH team
  `;
  const html = `
<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
  <h2 style="color: #333;">Uw nieuwe wachtwoord</h2>
  
  <p>Hallo,</p>
  
  <p>U heeft een nieuw wachtwoord aangevraagd voor uw IDARAH Ledenbeheer account.</p>
  
  <div style="background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin: 20px 0;">
    <strong>Uw nieuwe wachtwoord is: </strong>
    <code style="background-color: #e9ecef; padding: 4px 8px; border-radius: 3px; font-size: 16px;">${newPassword}</code>
  </div>
  
  <p>Log in op het systeem met dit nieuwe wachtwoord. We raden u aan om uw wachtwoord te wijzigen na het inloggen.</p>
  
  <p>Met vriendelijke groet,<br>Het IDARAH team</p>
</div>
  `;
  return { subject, text: text2, html };
}
var mailService, EmailService;
var init_email = __esm({
  "server/services/email.ts"() {
    "use strict";
    init_db();
    init_schema();
    mailService = new MailService();
    if (process.env.SENDGRID_API_KEY) {
      mailService.setApiKey(process.env.SENDGRID_API_KEY);
    }
    EmailService = class {
      transporter;
      constructor() {
        this.setupTransporter();
        this.registerHandlebarsHelpers();
      }
      setupTransporter() {
        this.transporter = nodemailer.createTransport({
          host: process.env.SMTP_HOST,
          port: parseInt(process.env.SMTP_PORT || "587"),
          secure: false,
          auth: {
            user: process.env.SMTP_USER,
            pass: process.env.SMTP_PASS
          }
        });
      }
      registerHandlebarsHelpers() {
        Handlebars.registerHelper("currency", function(amount) {
          return new Intl.NumberFormat("nl-BE", {
            style: "currency",
            currency: "EUR"
          }).format(amount);
        });
        Handlebars.registerHelper("date", function(date) {
          const d = typeof date === "string" ? new Date(date) : date;
          return d.toLocaleDateString("nl-BE");
        });
      }
      // Templates
      async listTemplates(tenantId) {
        const templates = await db.select().from(emailTemplates).where(eq2(emailTemplates.tenantId, tenantId)).orderBy(desc2(emailTemplates.createdAt));
        const seen = /* @__PURE__ */ new Set();
        return templates.filter((template) => {
          if (seen.has(template.id)) {
            return false;
          }
          seen.add(template.id);
          return true;
        });
      }
      async getTemplate(tenantId, id) {
        const [template] = await db.select().from(emailTemplates).where(and3(
          eq2(emailTemplates.tenantId, tenantId),
          eq2(emailTemplates.id, id)
        ));
        return template;
      }
      async createTemplate(tenantId, data) {
        const [template] = await db.insert(emailTemplates).values({ ...data, tenantId }).returning();
        return template;
      }
      async updateTemplate(tenantId, id, data) {
        const [template] = await db.update(emailTemplates).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(and3(
          eq2(emailTemplates.tenantId, tenantId),
          eq2(emailTemplates.id, id)
        )).returning();
        return template;
      }
      async deleteTemplate(tenantId, id) {
        await db.delete(emailTemplates).where(and3(
          eq2(emailTemplates.tenantId, tenantId),
          eq2(emailTemplates.id, id)
        ));
      }
      // Convert plain text to professional HTML
      convertToHTML(plainText) {
        if (!plainText?.trim()) return "";
        const baseStyle = `
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9f9f9; }
        .email-container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .content p { margin: 0 0 15px 0; }
        .highlight { background-color: #f8f9fa; padding: 15px; border-left: 4px solid #007bff; margin: 20px 0; border-radius: 0 4px 4px 0; }
        .expired-amount { background-color: #fef2f2; padding: 15px; border-left: 4px solid #dc2626; margin: 20px 0; border-radius: 0 4px 4px 0; }
        .expired-amount p { color: #991b1b; font-weight: 500; }
        .footer { text-align: center; padding-top: 20px; border-top: 1px solid #e0e0e0; margin-top: 25px; color: #666; font-size: 14px; }
        .button { display: inline-block; background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; margin: 10px 0; }
      </style>
    </head>
    <body>
      <div class="email-container">
        <div class="content">
    `;
        const htmlContent = plainText.split("\n\n").filter((p) => p.trim()).map((paragraph) => {
          const trimmed = paragraph.trim();
          if (trimmed.includes("{{") || trimmed.includes("http")) {
            if (trimmed.includes("http") || trimmed.includes("{{card.url}}")) {
              return `        <div class="highlight">
            <p>${trimmed}</p>
          </div>`;
            }
          }
          if (trimmed.includes("\u20AC") && (trimmed.includes("{{#each member.fees.expired}}") || trimmed.includes("{{member.fees.totalExpiredAmount}}") || trimmed.includes("Totaal vervallen bedrag"))) {
            return `        <div class="expired-amount">
          <p>${trimmed}</p>
        </div>`;
          }
          return `        <p>${trimmed}</p>`;
        }).join("\n");
        const footer = `
        </div>
      </div>
    </body>
    </html>`;
        return baseStyle + htmlContent + footer;
      }
      convertToPlainText(content) {
        if (!content?.trim()) return "";
        const lines = content.split("\n\n").filter((p) => p.trim()).join("\n\n");
        return lines;
      }
      // Render template with context
      async renderTemplate(templateId, context) {
        const template = await db.select().from(emailTemplates).where(eq2(emailTemplates.id, templateId)).limit(1);
        if (!template[0]) throw new Error("Template not found");
        const subjectTemplate = Handlebars.compile(template[0].subject);
        let htmlContent;
        let textContent;
        if (template[0].content) {
          htmlContent = this.convertToHTML(template[0].content);
          textContent = this.convertToPlainText(template[0].content);
        } else {
          htmlContent = template[0].bodyHtml || "";
          textContent = template[0].bodyText || "";
        }
        const htmlTemplate = Handlebars.compile(htmlContent);
        const textTemplate = textContent ? Handlebars.compile(textContent) : null;
        const enrichedContext = {
          ...context,
          openUrl: context.openUrl || "",
          clickUrl: (original) => context.clickUrl ? context.clickUrl(original) : original,
          unsubUrl: context.unsubUrl || "",
          now: (/* @__PURE__ */ new Date()).toISOString()
        };
        return {
          subject: subjectTemplate(enrichedContext),
          html: htmlTemplate(enrichedContext),
          text: textTemplate ? textTemplate(enrichedContext) : void 0
        };
      }
      // Segments
      async listSegments(tenantId) {
        return await db.select().from(emailSegments).where(eq2(emailSegments.tenantId, tenantId)).orderBy(desc2(emailSegments.createdAt));
      }
      async createSegment(tenantId, data) {
        const [segment] = await db.insert(emailSegments).values({ ...data, tenantId }).returning();
        return segment;
      }
      async deleteSegment(tenantId, id) {
        await db.delete(emailSegments).where(and3(
          eq2(emailSegments.tenantId, tenantId),
          eq2(emailSegments.id, id)
        ));
      }
      async resolveSegment(tenantId, rules2) {
        const conditions = [eq2(members.tenantId, tenantId)];
        if (rules2.memberActive !== void 0) {
          conditions.push(eq2(members.active, rules2.memberActive));
        }
        if (rules2.category && Array.isArray(rules2.category) && rules2.category.length > 0) {
          conditions.push(inArray(members.category, rules2.category));
        }
        if (rules2.gender && Array.isArray(rules2.gender) && rules2.gender.length > 0) {
          conditions.push(inArray(members.gender, rules2.gender));
        }
        if (rules2.city) {
          conditions.push(eq2(members.city, rules2.city));
        }
        if (rules2.createdFrom) {
          conditions.push(gte2(members.createdAt, new Date(rules2.createdFrom)));
        }
        if (rules2.createdTo) {
          conditions.push(lte2(members.createdAt, new Date(rules2.createdTo)));
        }
        const results = await db.select({
          id: members.id,
          email: members.email,
          firstName: members.firstName,
          lastName: members.lastName,
          category: members.category,
          active: members.active,
          city: members.city,
          postalCode: members.postalCode,
          createdAt: members.createdAt
        }).from(members).where(and3(...conditions));
        return results.filter((member) => member.email).map((member) => ({
          memberId: member.id,
          email: member.email
        }));
      }
      async previewSegment(tenantId, rules2) {
        const members2 = await this.resolveSegment(tenantId, rules2);
        return {
          count: members2.length,
          sample: members2.slice(0, 10)
          // First 10 members as preview
        };
      }
      // Build member context for template rendering
      async buildMemberContext(tenantId, memberId) {
        const [member] = await db.select().from(members).where(and3(
          eq2(members.tenantId, tenantId),
          eq2(members.id, memberId)
        ));
        if (!member) throw new Error("Member not found");
        const [tenant] = await db.select().from(tenants).where(eq2(tenants.id, tenantId));
        const memberFees = await db.select().from(membershipFees).where(and3(
          eq2(membershipFees.tenantId, tenantId),
          eq2(membershipFees.memberId, memberId)
        )).orderBy(desc2(membershipFees.periodStart)).limit(5);
        return {
          member: {
            ...member,
            city: member.city || "Onbekend"
          },
          tenant: tenant || { name: "Organisatie", logoUrl: "", primaryColor: "#000" },
          card: {
            url: `${process.env.APP_BASE_URL || "http://localhost:5000"}/card/${memberId}?standalone=1`
          },
          fees: memberFees.map((fee) => ({
            amount: fee.amount,
            periodStart: fee.periodStart,
            periodEnd: fee.periodEnd,
            status: fee.status
          }))
        };
      }
      // Check if email is suppressed
      async isEmailSuppressed(tenantId, email) {
        const [suppression] = await db.select().from(emailSuppresses).where(and3(
          eq2(emailSuppresses.tenantId, tenantId),
          eq2(emailSuppresses.email, email)
        )).limit(1);
        return !!suppression;
      }
      // Generate tracking tokens
      generateTokens() {
        return {
          openToken: randomBytes(16).toString("hex"),
          clickToken: randomBytes(16).toString("hex"),
          unsubToken: randomBytes(16).toString("hex")
        };
      }
      // Send single transactional email
      async sendTransactional(tenantId, templateCode, options) {
        const [template] = await db.select().from(emailTemplates).where(and3(
          eq2(emailTemplates.tenantId, tenantId),
          eq2(emailTemplates.code, templateCode)
        ));
        if (!template) throw new Error("Template not found");
        let context = options.context || {};
        if (options.memberId) {
          context = await this.buildMemberContext(tenantId, options.memberId);
        }
        const email = options.email || context.member?.email;
        if (!email) throw new Error("No email address provided");
        const tokens = this.generateTokens();
        const rendered = await this.renderTemplate(template.id, {
          ...context,
          openUrl: `${process.env.APP_BASE_URL}/api/messages/track/open/{{messageId}}/${tokens.openToken}.png`,
          clickUrl: (original) => `${process.env.APP_BASE_URL}/api/messages/track/click/{{messageId}}/${tokens.clickToken}?u=${encodeURIComponent(original)}`
        });
        const [message] = await db.insert(emailMessages).values({
          tenantId,
          templateId: template.id,
          memberId: options.memberId,
          email,
          subject: rendered.subject,
          bodyHtml: rendered.html,
          bodyText: rendered.text,
          tokens,
          status: "QUEUED"
        }).returning();
        const finalHtml = rendered.html.replace(/{{messageId}}/g, message.id);
        await db.update(emailMessages).set({
          bodyHtml: finalHtml
        }).where(eq2(emailMessages.id, message.id));
        try {
          await this.transporter.sendMail({
            from: process.env.SMTP_FROM,
            to: email,
            subject: rendered.subject,
            html: finalHtml,
            text: rendered.text
          });
          await db.update(emailMessages).set({
            status: "SENT",
            sentAt: /* @__PURE__ */ new Date()
          }).where(eq2(emailMessages.id, message.id));
          return message;
        } catch (error) {
          await db.update(emailMessages).set({
            status: "FAILED",
            lastError: error.message
          }).where(eq2(emailMessages.id, message.id));
          throw error;
        }
      }
      // Campaigns
      async listCampaigns(tenantId) {
        return await db.select({
          campaign: emailCampaigns,
          template: emailTemplates,
          segment: emailSegments
        }).from(emailCampaigns).leftJoin(emailTemplates, eq2(emailCampaigns.templateId, emailTemplates.id)).leftJoin(emailSegments, eq2(emailCampaigns.segmentId, emailSegments.id)).where(eq2(emailCampaigns.tenantId, tenantId)).orderBy(desc2(emailCampaigns.createdAt));
      }
      async createCampaign(tenantId, data) {
        const [campaign] = await db.insert(emailCampaigns).values({ ...data, tenantId }).returning();
        return campaign;
      }
      // Queue campaign for sending
      async queueCampaign(tenantId, campaignId) {
        const [campaign] = await db.select({
          campaign: emailCampaigns,
          template: emailTemplates,
          segment: emailSegments
        }).from(emailCampaigns).leftJoin(emailTemplates, eq2(emailCampaigns.templateId, emailTemplates.id)).leftJoin(emailSegments, eq2(emailCampaigns.segmentId, emailSegments.id)).where(and3(
          eq2(emailCampaigns.tenantId, tenantId),
          eq2(emailCampaigns.id, campaignId)
        ));
        if (!campaign) throw new Error("Campaign not found");
        let recipients = [];
        if (campaign.segment) {
          recipients = await this.resolveSegment(tenantId, campaign.segment.rules);
        }
        const messages = [];
        for (const recipient of recipients) {
          if (campaign.campaign.kind === "MARKETING") {
            const suppressed = await this.isEmailSuppressed(tenantId, recipient.email);
            if (suppressed) continue;
          }
          const context = await this.buildMemberContext(tenantId, recipient.memberId);
          const tokens = this.generateTokens();
          if (!campaign.template) {
            throw new Error("Campaign template not found");
          }
          const rendered = await this.renderTemplate(campaign.template.id, {
            ...context,
            openUrl: `${process.env.APP_BASE_URL}/api/messages/track/open/{{messageId}}/${tokens.openToken}.png`,
            clickUrl: (original) => `${process.env.APP_BASE_URL}/api/messages/track/click/{{messageId}}/${tokens.clickToken}?u=${encodeURIComponent(original)}`,
            unsubUrl: campaign.campaign.kind === "MARKETING" ? `${process.env.APP_BASE_URL}/email/unsubscribe?token=${tokens.unsubToken}` : void 0
          });
          messages.push({
            tenantId,
            campaignId,
            templateId: campaign.template.id,
            memberId: recipient.memberId,
            email: recipient.email,
            subject: rendered.subject,
            bodyHtml: rendered.html,
            bodyText: rendered.text,
            tokens,
            status: "QUEUED"
          });
        }
        if (messages.length > 0) {
          await db.insert(emailMessages).values(messages);
        }
        await db.update(emailCampaigns).set({
          status: "QUEUED",
          startedAt: /* @__PURE__ */ new Date()
        }).where(eq2(emailCampaigns.id, campaignId));
        return { messagesQueued: messages.length };
      }
      // Worker function to process queued messages
      async processQueuedMessages(limit = 50) {
        const queuedMessages = await db.select().from(emailMessages).where(eq2(emailMessages.status, "QUEUED")).limit(limit);
        const results = {
          processed: 0,
          sent: 0,
          failed: 0
        };
        for (const message of queuedMessages) {
          try {
            const finalHtml = message.bodyHtml.replace(/{{messageId}}/g, message.id);
            await this.transporter.sendMail({
              from: process.env.SMTP_FROM,
              to: message.email,
              subject: message.subject,
              html: finalHtml,
              text: message.bodyText
            });
            await db.update(emailMessages).set({
              status: "SENT",
              sentAt: /* @__PURE__ */ new Date(),
              bodyHtml: finalHtml
              // Save final version
            }).where(eq2(emailMessages.id, message.id));
            results.sent++;
          } catch (error) {
            const retryCount = message.retryCount + 1;
            const status = retryCount >= 3 ? "FAILED" : "QUEUED";
            await db.update(emailMessages).set({
              status,
              lastError: error.message,
              retryCount
            }).where(eq2(emailMessages.id, message.id));
            if (status === "FAILED") {
              results.failed++;
            }
          }
          results.processed++;
          const ratePerMinute = parseInt(process.env.EMAIL_RATE_PER_MIN || "50");
          const delayMs = 60 * 1e3 / ratePerMinute;
          await new Promise((resolve) => setTimeout(resolve, delayMs));
        }
        return results;
      }
      // Tracking
      async trackOpen(messageId, openToken) {
        const [message] = await db.select().from(emailMessages).where(eq2(emailMessages.id, messageId));
        if (!message || message.tokens?.openToken !== openToken) {
          return false;
        }
        if (!message.openedAt) {
          await db.update(emailMessages).set({
            openedAt: /* @__PURE__ */ new Date(),
            status: "OPENED"
          }).where(eq2(emailMessages.id, messageId));
        }
        return true;
      }
      async trackClick(messageId, clickToken, originalUrl) {
        const [message] = await db.select().from(emailMessages).where(eq2(emailMessages.id, messageId));
        if (!message || message.tokens?.clickToken !== clickToken) {
          return null;
        }
        if (!message.clickedAt) {
          await db.update(emailMessages).set({
            clickedAt: /* @__PURE__ */ new Date(),
            status: "CLICKED"
          }).where(eq2(emailMessages.id, messageId));
        }
        return originalUrl;
      }
      // Suppress email
      async suppressEmail(tenantId, email, memberId, reason = "UNSUB_REQUEST") {
        await db.insert(emailSuppresses).values({
          tenantId,
          email,
          memberId,
          reason
        }).onConflictDoNothing();
      }
      // Test email
      async sendTestEmail(tenantId, templateId, toEmail, sampleContext) {
        const context = sampleContext || await this.buildSampleContext(tenantId);
        const rendered = await this.renderTemplate(templateId, context);
        await this.transporter.sendMail({
          from: process.env.SMTP_FROM,
          to: toEmail,
          subject: `[TEST] ${rendered.subject}`,
          html: rendered.html,
          text: rendered.text
        });
      }
      async buildSampleContext(tenantId) {
        const [sampleMember] = await db.select().from(members).where(and3(
          eq2(members.tenantId, tenantId),
          eq2(members.active, true)
        )).limit(1);
        if (sampleMember) {
          return await this.buildMemberContext(tenantId, sampleMember.id);
        }
        return {
          member: {
            firstName: "Jan",
            lastName: "Voorbeeld",
            email: "jan@voorbeeld.be",
            memberNumber: "12345",
            category: "STANDAARD",
            city: "Antwerpen"
          },
          tenant: { name: "Moskee Voorbeeld", logoUrl: "", primaryColor: "#000" },
          card: { url: "#" },
          fees: []
        };
      }
    };
  }
});

// server/lib/time/beTime.ts
import { fromZonedTime, toZonedTime } from "date-fns-tz";
import { format, isValid } from "date-fns";
import { nl } from "date-fns/locale";
function nowBE() {
  return toZonedTime(/* @__PURE__ */ new Date(), BE_TIMEZONE);
}
function toBEDate(date) {
  if (!isValid(date)) {
    throw new Error("Invalid date provided");
  }
  return toZonedTime(date, BE_TIMEZONE);
}
function startOfDayBE(date) {
  if (!isValid(date)) {
    throw new Error("Invalid date provided");
  }
  const beDate = toBEDate(date);
  const startOfDay2 = new Date(beDate);
  startOfDay2.setHours(0, 0, 0, 0);
  return startOfDay2;
}
var BE_TIMEZONE;
var init_beTime = __esm({
  "server/lib/time/beTime.ts"() {
    "use strict";
    BE_TIMEZONE = "Europe/Brussels";
  }
});

// server/lib/fees/periods.ts
import { addMonths, addYears, startOfDay } from "date-fns";
function isDateInPeriod(date, period) {
  const checkDate = toBEDate(date);
  const periodStart = toBEDate(period.start);
  const periodEnd = toBEDate(period.end);
  return checkDate >= periodStart && checkDate < periodEnd;
}
var init_periods = __esm({
  "server/lib/fees/periods.ts"() {
    "use strict";
    init_beTime();
  }
});

// server/lib/card/status.ts
var status_exports = {};
__export(status_exports, {
  computeCardStatus: () => computeCardStatus,
  getCardStatusDetails: () => getCardStatusDetails,
  getLatestPaidPeriod: () => getLatestPaidPeriod,
  isMembershipExpired: () => isMembershipExpired,
  memberHasPaidPeriods: () => memberHasPaidPeriods
});
async function isMembershipExpired(memberId) {
  try {
    const fees = await storage.getMembershipFeesByMember(memberId);
    if (fees.length === 0) {
      return false;
    }
    return fees.some((fee) => fee.status === "OVERDUE");
  } catch (error) {
    console.error("Error checking membership expiry:", error);
    return false;
  }
}
async function computeCardStatus(memberId) {
  try {
    const expired = await isMembershipExpired(memberId);
    if (expired) {
      return "VERLOPEN";
    }
    return "ACTUEEL";
  } catch (error) {
    console.error("Error computing card status:", error);
    return "ACTUEEL";
  }
}
async function getCardStatusDetails(memberId) {
  const status = await computeCardStatus(memberId);
  const fees = await storage.getMembershipFeesByMember(memberId);
  const now = nowBE();
  const periods = fees.map((fee) => ({
    ...fee,
    periodStart: toBEDate(fee.periodStart),
    periodEnd: toBEDate(fee.periodEnd),
    paidAt: fee.paidAt ? toBEDate(fee.paidAt) : null
  }));
  const activePeriod = periods.find(
    (period) => isDateInPeriod(now, {
      start: period.periodStart,
      end: period.periodEnd
    })
  );
  const latestPeriod = periods.reduce(
    (latest, current) => current.periodEnd > latest.periodEnd ? current : latest
  );
  return {
    status,
    activePeriod: activePeriod || null,
    latestPeriod: latestPeriod || null,
    allPeriods: periods,
    computedAt: now,
    reason: getStatusReason(status, activePeriod, latestPeriod, now)
  };
}
function getStatusReason(status, activePeriod, latestPeriod, now) {
  switch (status) {
    case "ACTUEEL":
      return activePeriod ? `Lopende periode betaald tot ${latestPeriod?.periodEnd?.toLocaleDateString("nl-BE")}` : "Lidmaatschap is actief";
    case "VERLOPEN":
      return latestPeriod ? `Verlopen sinds ${latestPeriod.periodEnd.toLocaleDateString("nl-BE")}` : "Lidmaatschap is verlopen";
    case "NIET_ACTUEEL":
      return "Lidmaatschap status onduidelijk";
    default:
      return "Onbekende status";
  }
}
async function memberHasPaidPeriods(memberId) {
  try {
    const fees = await storage.getMembershipFeesByMember(memberId);
    return fees.some((fee) => fee.status === "PAID");
  } catch (error) {
    console.error("Error checking paid periods:", error);
    return false;
  }
}
async function getLatestPaidPeriod(memberId) {
  try {
    const fees = await storage.getMembershipFeesByMember(memberId);
    const paidFees = fees.filter((fee) => fee.status === "PAID");
    if (paidFees.length === 0) {
      return null;
    }
    return paidFees.reduce(
      (latest, current) => current.periodEnd > latest.periodEnd ? current : latest
    );
  } catch (error) {
    console.error("Error getting latest paid period:", error);
    return null;
  }
}
var init_status = __esm({
  "server/lib/card/status.ts"() {
    "use strict";
    init_storage();
    init_beTime();
    init_periods();
  }
});

// server/lib/card/simple-validuntil.ts
var simple_validuntil_exports = {};
__export(simple_validuntil_exports, {
  getMemberValidUntil: () => getMemberValidUntil,
  isMemberCardValid: () => isMemberCardValid,
  updateMemberValidUntil: () => updateMemberValidUntil
});
async function updateMemberValidUntil(memberId) {
  try {
    const fees = await storage.getMembershipFeesByMember(memberId);
    if (fees.length === 0) {
      return null;
    }
    const paidFees = fees.filter((fee) => fee.status === "PAID");
    if (paidFees.length === 0) {
      return null;
    }
    const latestPaidPeriod = paidFees.reduce(
      (latest, current) => toBEDate(current.periodEnd) > toBEDate(latest.periodEnd) ? current : latest
    );
    const validUntilDate = toBEDate(latestPaidPeriod.periodEnd);
    try {
      const cardMeta2 = await storage.getCardMetaByMember(memberId);
      if (cardMeta2) {
        await storage.updateCardMeta(cardMeta2.id, {
          validUntil: validUntilDate,
          version: (cardMeta2.version || 1) + 1
        });
      }
    } catch (error) {
      console.warn("Could not update card meta:", error);
    }
    return validUntilDate;
  } catch (error) {
    console.error("Error updating validUntil:", error);
    throw error;
  }
}
async function getMemberValidUntil(memberId) {
  try {
    const fees = await storage.getMembershipFeesByMember(memberId);
    const paidFees = fees.filter((fee) => fee.status === "PAID");
    if (paidFees.length === 0) {
      return null;
    }
    const latestPaidPeriod = paidFees.reduce(
      (latest, current) => toBEDate(current.periodEnd) > toBEDate(latest.periodEnd) ? current : latest
    );
    return toBEDate(latestPaidPeriod.periodEnd);
  } catch (error) {
    console.error("Error getting validUntil:", error);
    return null;
  }
}
async function isMemberCardValid(memberId) {
  const validUntil = await getMemberValidUntil(memberId);
  if (!validUntil) {
    return false;
  }
  const now = /* @__PURE__ */ new Date();
  return now <= validUntil;
}
var init_simple_validuntil = __esm({
  "server/lib/card/simple-validuntil.ts"() {
    "use strict";
    init_storage();
    init_beTime();
  }
});

// server/lib/fees/rollover.ts
var rollover_exports = {};
__export(rollover_exports, {
  checkRolloverNeeded: () => checkRolloverNeeded,
  rolloverDaily: () => rolloverDaily,
  rolloverForMember: () => rolloverForMember
});
async function rolloverDaily(tenantId) {
  const startTime = nowBE();
  const today = startOfDayBE(nowBE());
  console.log(`Starting daily rollover for ${tenantId ? `tenant ${tenantId}` : "all tenants"} at ${startTime.toISOString()}`);
  const summary = {
    processedAt: startTime,
    tenantId,
    expiredFeesCount: 0,
    newPeriodsCreated: 0,
    cardsUpdated: 0,
    errors: []
  };
  try {
    const allFees = tenantId ? await storage.getMembershipFeesByTenant(tenantId) : await storage.getAllMembershipFees();
    const expiredFees = allFees.filter((fee) => {
      const periodEnd = toBEDate(fee.periodEnd);
      return fee.status === "OPEN" && today > periodEnd;
    });
    console.log(`Found ${expiredFees.length} expired fees to mark as overdue`);
    for (const fee of expiredFees) {
      try {
        await storage.updateMembershipFee(fee.id, {
          status: "OVERDUE"
        });
        summary.expiredFeesCount++;
      } catch (error) {
        summary.errors.push({
          memberId: fee.memberId,
          error: `Failed to mark fee ${fee.id} as overdue: ${error}`
        });
      }
    }
    const affectedMemberIds = [...new Set(expiredFees.map((fee) => fee.memberId))];
    for (const memberId of affectedMemberIds) {
      try {
        const newStatus = await computeCardStatus(memberId);
        const cardMeta2 = await storage.getCardMetaByMember(memberId);
        if (cardMeta2 && cardMeta2.status !== newStatus) {
          await storage.updateCardMeta(cardMeta2.id, {
            status: newStatus,
            version: (cardMeta2.version || 1) + 1
          });
          summary.cardsUpdated++;
          console.log(`Updated card status for member ${memberId}: ${cardMeta2.status} -> ${newStatus}`);
        }
      } catch (error) {
        summary.errors.push({
          memberId,
          error: `Failed to update card status: ${error}`
        });
      }
    }
    console.log(`Daily rollover completed: ${summary.expiredFeesCount} fees expired, ${summary.cardsUpdated} cards updated`);
  } catch (error) {
    console.error("Daily rollover failed:", error);
    summary.errors.push({
      memberId: "SYSTEM",
      error: `Rollover process failed: ${error}`
    });
  }
  return summary;
}
async function rolloverForMember(memberId) {
  const today = startOfDayBE(nowBE());
  const fees = await storage.getMembershipFeesByMember(memberId);
  for (const fee of fees) {
    if (fee.status === "OPEN" && toBEDate(fee.periodEnd) < today) {
      await storage.updateMembershipFee(fee.id, {
        status: "OVERDUE"
      });
    }
  }
  const newStatus = await computeCardStatus(memberId);
  const cardMeta2 = await storage.getCardMetaByMember(memberId);
  if (cardMeta2 && cardMeta2.status !== newStatus) {
    await storage.updateCardMeta(cardMeta2.id, {
      status: newStatus,
      version: (cardMeta2.version || 1) + 1
    });
  }
}
async function checkRolloverNeeded(tenantId) {
  const today = startOfDayBE(nowBE());
  const allFees = tenantId ? await storage.getMembershipFeesByTenant(tenantId) : await storage.getAllMembershipFees();
  const needsRollover = allFees.some((fee) => {
    const periodEnd = toBEDate(fee.periodEnd);
    return fee.status === "OPEN" && today > periodEnd;
  });
  return needsRollover;
}
var init_rollover = __esm({
  "server/lib/fees/rollover.ts"() {
    "use strict";
    init_storage();
    init_beTime();
    init_status();
  }
});

// lib/reconcile/parsers/csv.ts
import { z as z5 } from "zod";
import { parseISO } from "date-fns";
import { zonedTimeToUtc } from "date-fns-tz";
var csvConfigSchema, parsedTransactionSchema, CsvParser, bankConfigs;
var init_csv = __esm({
  "lib/reconcile/parsers/csv.ts"() {
    "use strict";
    csvConfigSchema = z5.object({
      delimiter: z5.string().default(","),
      hasHeader: z5.boolean().default(true),
      skipLines: z5.number().default(0),
      columns: z5.object({
        date: z5.string().or(z5.number()),
        amount: z5.string().or(z5.number()),
        description: z5.string().or(z5.number()),
        counterparty: z5.string().or(z5.number()).optional(),
        iban: z5.string().or(z5.number()).optional(),
        ref: z5.string().or(z5.number()).optional()
      }),
      dateFormat: z5.string().default("dd/MM/yyyy"),
      // Belgisch formaat
      decimalSeparator: z5.string().default(","),
      thousandsSeparator: z5.string().default(".")
    });
    parsedTransactionSchema = z5.object({
      bookingDate: z5.date(),
      valueDate: z5.date().optional(),
      amount: z5.number(),
      // in centen
      currency: z5.string().default("EUR"),
      counterparty: z5.string().optional(),
      iban: z5.string().optional(),
      description: z5.string().optional(),
      ref: z5.string().optional(),
      side: z5.enum(["CREDIT", "DEBET"])
    });
    CsvParser = class {
      config;
      constructor(config = {}) {
        this.config = csvConfigSchema.parse(config);
      }
      /**
       * Parse CSV content naar transacties
       */
      parse(csvContent) {
        const lines = csvContent.split("\n").filter((line) => line.trim());
        const dataLines = lines.slice(this.config.skipLines);
        const transactionLines = this.config.hasHeader ? dataLines.slice(1) : dataLines;
        return transactionLines.map((line, index) => {
          try {
            return this.parseLine(line);
          } catch (error) {
            console.warn(`Fout bij verwerken lijn ${index + 1}:`, error);
            return null;
          }
        }).filter((tx) => tx !== null);
      }
      /**
       * Parse een enkele CSV lijn
       */
      parseLine(line) {
        const fields = this.splitCsvLine(line);
        const dateStr = this.getField(fields, this.config.columns.date);
        const amountStr = this.getField(fields, this.config.columns.amount);
        const description = this.getField(fields, this.config.columns.description);
        const counterparty = this.config.columns.counterparty ? this.getField(fields, this.config.columns.counterparty) : void 0;
        const iban = this.config.columns.iban ? this.getField(fields, this.config.columns.iban) : void 0;
        const ref = this.config.columns.ref ? this.getField(fields, this.config.columns.ref) : void 0;
        const bookingDate = this.parseDate(dateStr);
        const amount = this.parseAmount(amountStr);
        const side = amount >= 0 ? "CREDIT" : "DEBET";
        return parsedTransactionSchema.parse({
          bookingDate,
          amount: Math.abs(amount),
          // Altijd positief opslaan, side bepaalt richting
          currency: "EUR",
          counterparty: counterparty?.trim() || void 0,
          iban: iban?.trim() || void 0,
          description: description?.trim() || void 0,
          ref: ref?.trim() || void 0,
          side
        });
      }
      /**
       * Split CSV lijn met respect voor quotes
       */
      splitCsvLine(line) {
        const fields = [];
        let current = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === this.config.delimiter && !inQuotes) {
            fields.push(current);
            current = "";
          } else {
            current += char;
          }
        }
        fields.push(current);
        return fields.map((f) => f.replace(/^"|"$/g, ""));
      }
      /**
       * Haal veld op basis van kolom index of naam
       */
      getField(fields, column) {
        if (typeof column === "number") {
          return fields[column] || "";
        }
        throw new Error(`Column mapping by name not implemented: ${column}`);
      }
      /**
       * Parse datum string naar Date object (Europe/Brussels tijdzone)
       */
      parseDate(dateStr) {
        try {
          const normalized = dateStr.replace(/[\/\-\.]/g, "/").trim();
          if (normalized.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
            const [day, month, year] = normalized.split("/");
            const isoDate = `${year}-${month.padStart(2, "0")}-${day.padStart(2, "0")}`;
            return zonedTimeToUtc(parseISO(isoDate), "Europe/Brussels");
          }
          if (normalized.match(/^\d{4}\/\d{1,2}\/\d{1,2}$/)) {
            return zonedTimeToUtc(parseISO(normalized.replace(/\//g, "-")), "Europe/Brussels");
          }
          throw new Error(`Onbekend datum formaat: ${dateStr}`);
        } catch (error) {
          throw new Error(`Fout bij parsen datum '${dateStr}': ${error}`);
        }
      }
      /**
       * Parse bedrag string naar centen (integer)
       */
      parseAmount(amountStr) {
        try {
          let normalized = amountStr.trim();
          normalized = normalized.replace(/[€$£]/g, "");
          if (this.config.decimalSeparator === "," && this.config.thousandsSeparator === ".") {
            const parts = normalized.split(",");
            if (parts.length === 1) {
              const euros = parseInt(parts[0].replace(/\./g, ""), 10);
              return euros * 100;
            } else if (parts.length === 2) {
              const euros = parseInt(parts[0].replace(/\./g, ""), 10);
              const cents = parseInt(parts[1].padEnd(2, "0").slice(0, 2), 10);
              return euros * 100 + cents;
            }
          }
          const amount = parseFloat(normalized.replace(/[^\d\.\-]/g, ""));
          return Math.round(amount * 100);
        } catch (error) {
          throw new Error(`Fout bij parsen bedrag '${amountStr}': ${error}`);
        }
      }
    };
    bankConfigs = {
      KBC: {
        delimiter: ";",
        hasHeader: true,
        columns: {
          date: 2,
          // Datum
          amount: 7,
          // Bedrag
          description: 8,
          // Mededeling
          counterparty: 4,
          // Tegenpartij
          iban: 5,
          // Rekening tegenpartij
          ref: 9
          // Referentie
        },
        dateFormat: "dd/MM/yyyy"
      },
      ING: {
        delimiter: ",",
        hasHeader: true,
        columns: {
          date: 0,
          amount: 6,
          description: 8,
          counterparty: 2,
          iban: 3,
          ref: 7
        }
      },
      BNP_PARIBAS_FORTIS: {
        delimiter: ";",
        hasHeader: true,
        columns: {
          date: 1,
          amount: 3,
          description: 4,
          counterparty: 5,
          ref: 6
        }
      }
    };
  }
});

// lib/reconcile/parsers/mt940.ts
import { zonedTimeToUtc as zonedTimeToUtc2 } from "date-fns-tz";
var Mt940Parser;
var init_mt940 = __esm({
  "lib/reconcile/parsers/mt940.ts"() {
    "use strict";
    init_csv();
    Mt940Parser = class {
      /**
       * Parse MT940 content naar transacties
       */
      parse(mt940Content) {
        const transactions2 = [];
        const lines = mt940Content.split("\n").map((line) => line.trim());
        let currentTransaction = {};
        let statementDate = null;
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.startsWith(":20:")) {
            continue;
          }
          if (line.startsWith(":25:")) {
            continue;
          }
          if (line.startsWith(":28C:")) {
            continue;
          }
          if (line.startsWith(":60F:") || line.startsWith(":60M:")) {
            statementDate = this.parseStatementDate(line);
            continue;
          }
          if (line.startsWith(":61:")) {
            if (Object.keys(currentTransaction).length > 0) {
              try {
                const parsed = this.finalizeTransaction(currentTransaction, statementDate);
                if (parsed) {
                  transactions2.push(parsed);
                }
              } catch (error) {
                console.warn("Fout bij verwerken MT940 transactie:", error);
              }
            }
            currentTransaction = this.parseStatementLine(line, statementDate);
          }
          if (line.startsWith(":86:")) {
            const description = line.substring(4);
            currentTransaction.description = description;
            currentTransaction.ref = this.extractReference(description);
            currentTransaction.counterparty = this.extractCounterparty(description);
          }
          if (line.startsWith(":62F:") || line.startsWith(":62M:")) {
            if (Object.keys(currentTransaction).length > 0) {
              try {
                const parsed = this.finalizeTransaction(currentTransaction, statementDate);
                if (parsed) {
                  transactions2.push(parsed);
                }
              } catch (error) {
                console.warn("Fout bij verwerken laatste MT940 transactie:", error);
              }
            }
            break;
          }
        }
        return transactions2;
      }
      /**
       * Parse statement datum uit opening balance lijn
       */
      parseStatementDate(line) {
        const match = line.match(/:60[FM]:([CD])(\d{6})/);
        if (!match) {
          throw new Error(`Ongeldig opening balance formaat: ${line}`);
        }
        const dateStr = match[2];
        const year = 2e3 + parseInt(dateStr.substring(0, 2), 10);
        const month = parseInt(dateStr.substring(2, 4), 10);
        const day = parseInt(dateStr.substring(4, 6), 10);
        return zonedTimeToUtc2(new Date(year, month - 1, day), "Europe/Brussels");
      }
      /**
       * Parse statement lijn (:61:)
       */
      parseStatementLine(line, statementDate) {
        try {
          const content = line.substring(4);
          const dateStr = content.substring(0, 6);
          const year = 2e3 + parseInt(dateStr.substring(0, 2), 10);
          const month = parseInt(dateStr.substring(2, 4), 10);
          const day = parseInt(dateStr.substring(4, 6), 10);
          const bookingDate = zonedTimeToUtc2(new Date(year, month - 1, day), "Europe/Brussels");
          const cdMatch = content.match(/([CD])([0-9,]+)/);
          if (!cdMatch) {
            throw new Error(`Kan C/D en bedrag niet vinden in: ${line}`);
          }
          const side = cdMatch[1] === "C" ? "CREDIT" : "DEBET";
          const amountStr = cdMatch[2];
          const amount = this.parseAmount(amountStr);
          return {
            bookingDate,
            amount,
            currency: "EUR",
            side
          };
        } catch (error) {
          console.warn(`Fout bij parsen statement lijn: ${line}`, error);
          return {};
        }
      }
      /**
       * Finaliseer transactie object
       */
      finalizeTransaction(transaction, fallbackDate) {
        try {
          return parsedTransactionSchema.parse({
            bookingDate: transaction.bookingDate || fallbackDate || /* @__PURE__ */ new Date(),
            valueDate: transaction.valueDate,
            amount: transaction.amount || 0,
            currency: transaction.currency || "EUR",
            counterparty: transaction.counterparty,
            iban: transaction.iban,
            description: transaction.description,
            ref: transaction.ref,
            side: transaction.side || "CREDIT"
          });
        } catch (error) {
          console.warn("Fout bij finaliseren transactie:", error);
          return null;
        }
      }
      /**
       * Extract reference from description
       */
      extractReference(description) {
        const refMatch = description.match(/(?:REF|REFERENCE|MEDEDELING)[:]\s*([^\s]+)/i);
        return refMatch?.[1];
      }
      /**
       * Extract counterparty from description
       */
      extractCounterparty(description) {
        const lines = description.split(/[\/\\]/);
        for (const line of lines) {
          if (line.trim() && !line.match(/^\d+$/) && !line.match(/^[A-Z]{2}\d+/)) {
            return line.trim();
          }
        }
        return void 0;
      }
      /**
       * Parse bedrag string naar centen
       */
      parseAmount(amountStr) {
        try {
          const normalized = amountStr.replace(",", ".");
          const euros = parseFloat(normalized);
          return Math.round(euros * 100);
        } catch (error) {
          throw new Error(`Fout bij parsen bedrag '${amountStr}': ${error}`);
        }
      }
    };
  }
});

// lib/reconcile/parsers/coda.ts
import { zonedTimeToUtc as zonedTimeToUtc3 } from "date-fns-tz";
var CodaParser;
var init_coda = __esm({
  "lib/reconcile/parsers/coda.ts"() {
    "use strict";
    init_csv();
    CodaParser = class {
      /**
       * Parse CODA content naar transacties
       */
      parse(codaContent) {
        const transactions2 = [];
        const lines = codaContent.split("\n").map((line) => line.trim());
        let currentAccount = null;
        let statementDate = null;
        for (const line of lines) {
          if (line.length === 0) continue;
          const recordType = line.substring(0, 1);
          switch (recordType) {
            case "0":
              break;
            case "1":
              currentAccount = this.parseAccountRecord(line);
              statementDate = this.parseStatementDate(line);
              break;
            case "2":
              try {
                const transaction = this.parseTransactionRecord(line, statementDate);
                if (transaction) {
                  transactions2.push(transaction);
                }
              } catch (error) {
                console.warn("Fout bij verwerken CODA transactie:", error);
              }
              break;
            case "3":
              break;
            case "4":
              break;
            case "8":
              break;
            case "9":
              break;
            default:
              console.warn(`Onbekend CODA record type: ${recordType}`);
          }
        }
        return transactions2;
      }
      /**
       * Parse account identification record (type 1)
       */
      parseAccountRecord(line) {
        return line.substring(4, 16).trim();
      }
      /**
       * Parse statement date from account record
       */
      parseStatementDate(line) {
        try {
          const dateStr = line.substring(57, 63);
          const day = parseInt(dateStr.substring(0, 2), 10);
          const month = parseInt(dateStr.substring(2, 4), 10);
          const year = 2e3 + parseInt(dateStr.substring(4, 6), 10);
          return zonedTimeToUtc3(new Date(year, month - 1, day), "Europe/Brussels");
        } catch (error) {
          console.warn("Fout bij parsen CODA datum:", error);
          return /* @__PURE__ */ new Date();
        }
      }
      /**
       * Parse transaction record (type 2)
       */
      parseTransactionRecord(line, statementDate) {
        try {
          if (line.length < 128) {
            throw new Error(`CODA lijn te kort: ${line.length} karakters`);
          }
          const dateStr = line.substring(13, 19);
          const day = parseInt(dateStr.substring(0, 2), 10);
          const month = parseInt(dateStr.substring(2, 4), 10);
          const year = 2e3 + parseInt(dateStr.substring(4, 6), 10);
          const bookingDate = zonedTimeToUtc3(new Date(year, month - 1, day), "Europe/Brussels");
          const cdIndicator = line.substring(23, 24);
          const side = cdIndicator === "1" ? "CREDIT" : "DEBET";
          const amountStr = line.substring(24, 39);
          const amountCents = parseInt(amountStr, 10);
          const currency = line.substring(39, 42).trim() || "EUR";
          const communication = line.substring(62, 113).trim();
          const bankRef = line.substring(7, 13).trim();
          return parsedTransactionSchema.parse({
            bookingDate,
            amount: amountCents,
            currency,
            side,
            description: communication || void 0,
            ref: bankRef || void 0,
            // CODA bevat meestal geen IBAN info in transaction records
            counterparty: this.extractCounterpartyFromCommunication(communication)
          });
        } catch (error) {
          console.warn(`Fout bij parsen CODA transactie record: ${line}`, error);
          return null;
        }
      }
      /**
       * Extract counterparty information from communication field
       */
      extractCounterpartyFromCommunication(communication) {
        if (!communication || communication.trim().length === 0) {
          return void 0;
        }
        const trimmed = communication.trim();
        const cleaned = trimmed.replace(/^(OVERSCHRIJVING|STORTING|DOMICILIERING|KAART)/i, "").trim();
        return cleaned.length > 0 ? cleaned : void 0;
      }
    };
  }
});

// lib/reconcile/import.ts
var import_exports = {};
__export(import_exports, {
  StatementImportService: () => StatementImportService,
  importFileSchema: () => importFileSchema,
  importOptionsSchema: () => importOptionsSchema
});
import { z as z6 } from "zod";
var importFileSchema, importOptionsSchema, StatementImportService;
var init_import = __esm({
  "lib/reconcile/import.ts"() {
    "use strict";
    init_csv();
    init_mt940();
    init_coda();
    importFileSchema = z6.object({
      filename: z6.string(),
      content: z6.string(),
      size: z6.number().max(10 * 1024 * 1024),
      // Max 10MB
      type: z6.enum(["CSV", "MT940", "CODA"])
    });
    importOptionsSchema = z6.object({
      sourceName: z6.string().min(1, "Bron naam is verplicht"),
      type: z6.enum(["CSV", "MT940", "CODA"]),
      csvConfig: z6.object({
        delimiter: z6.string().default(","),
        hasHeader: z6.boolean().default(true),
        skipLines: z6.number().default(0),
        columns: z6.object({
          date: z6.number(),
          amount: z6.number(),
          description: z6.number(),
          counterparty: z6.number().optional(),
          iban: z6.number().optional(),
          ref: z6.number().optional()
        }),
        bankPreset: z6.enum(["KBC", "ING", "BNP_PARIBAS_FORTIS", "CUSTOM"]).optional()
      }).optional()
    });
    StatementImportService = class {
      /**
       * Importeer bankafschrift en creëer statement + transacties
       */
      async importStatement(file, options, tenantId, userId) {
        const validatedFile = importFileSchema.parse(file);
        const validatedOptions = importOptionsSchema.parse(options);
        const parsedTransactions = await this.parseTransactions(
          validatedFile.content,
          validatedOptions
        );
        if (parsedTransactions.length === 0) {
          throw new Error("Geen geldige transacties gevonden in het bestand");
        }
        const statementData = {
          tenantId,
          type: validatedOptions.type,
          sourceName: validatedOptions.sourceName,
          importedById: userId,
          numTx: parsedTransactions.length,
          rawFileUrl: null
          // TODO: Implementeer file storage
        };
        const statement = {
          id: "mock-statement-id",
          ...statementData,
          importedAt: /* @__PURE__ */ new Date()
        };
        const bankTransactions2 = parsedTransactions.map((parsed, index) => ({
          id: `mock-transaction-${index}`,
          tenantId,
          statementId: statement.id,
          bookingDate: parsed.bookingDate,
          valueDate: parsed.valueDate || null,
          side: parsed.side,
          amount: parsed.amount.toString(),
          // Decimal als string
          currency: parsed.currency,
          counterparty: parsed.counterparty || null,
          iban: parsed.iban || null,
          description: parsed.description || null,
          ref: parsed.ref || null,
          status: "ONTVANGEN",
          categoryId: null,
          vendorId: null,
          matchedFeeId: null,
          matchedMemberId: null,
          matchScore: null,
          notes: null,
          createdAt: /* @__PURE__ */ new Date()
        }));
        return {
          statement,
          transactions: bankTransactions2
        };
      }
      /**
       * Parse transacties op basis van bestandstype
       */
      async parseTransactions(content, options) {
        switch (options.type) {
          case "CSV":
            return this.parseCsvTransactions(content, options.csvConfig);
          case "MT940":
            const mt940Parser = new Mt940Parser();
            return mt940Parser.parse(content);
          case "CODA":
            const codaParser = new CodaParser();
            return codaParser.parse(content);
          default:
            throw new Error(`Onondersteund bestandstype: ${options.type}`);
        }
      }
      /**
       * Parse CSV transacties met configuratie
       */
      parseCsvTransactions(content, csvConfig) {
        let config;
        if (csvConfig?.bankPreset && csvConfig.bankPreset !== "CUSTOM") {
          const bankConfig = bankConfigs[csvConfig.bankPreset];
          config = {
            ...bankConfig,
            ...csvConfig,
            // Override met custom settings
            dateFormat: csvConfig.dateFormat || bankConfig.dateFormat || "dd/MM/yyyy",
            decimalSeparator: csvConfig.decimalSeparator || ",",
            thousandsSeparator: csvConfig.thousandsSeparator || "."
          };
        } else if (csvConfig) {
          config = csvConfig;
        } else {
          config = {
            delimiter: ",",
            hasHeader: true,
            skipLines: 0,
            columns: {
              date: 0,
              amount: 1,
              description: 2,
              counterparty: 3,
              iban: 4,
              ref: 5
            },
            dateFormat: "dd/MM/yyyy",
            decimalSeparator: ",",
            thousandsSeparator: "."
          };
        }
        const parser = new CsvParser(config);
        return parser.parse(content);
      }
      /**
       * Valideer bestand voordat import
       */
      validateFile(file) {
        const errors = [];
        try {
          importFileSchema.parse(file);
        } catch (error) {
          if (error instanceof z6.ZodError) {
            errors.push(...error.errors.map((e) => e.message));
          } else {
            errors.push("Onbekende validatiefout");
          }
        }
        if (file.content.trim().length === 0) {
          errors.push("Bestand is leeg");
        }
        if (file.type === "CSV") {
          const lines = file.content.split("\n").filter((l) => l.trim());
          if (lines.length < 2) {
            errors.push("CSV bestand moet minimaal 2 lijnen bevatten");
          }
        }
        return {
          valid: errors.length === 0,
          errors
        };
      }
      /**
       * Detecteer automatisch bestandstype op basis van content
       */
      detectFileType(content) {
        const trimmed = content.trim();
        if (trimmed.match(/^0\d{8}/)) {
          return "CODA";
        }
        if (trimmed.includes(":20:") && trimmed.includes(":25:")) {
          return "MT940";
        }
        if (trimmed.includes(",") || trimmed.includes(";")) {
          return "CSV";
        }
        return "UNKNOWN";
      }
      /**
       * Preview transacties zonder opslaan
       */
      async previewTransactions(file, options) {
        const errors = [];
        try {
          const parsedTransactions = await this.parseTransactions(file.content, options);
          return {
            count: parsedTransactions.length,
            sample: parsedTransactions.slice(0, 5),
            // Eerste 5 transacties als voorbeeld
            errors
          };
        } catch (error) {
          errors.push(error instanceof Error ? error.message : "Onbekende fout bij preview");
          return {
            count: 0,
            sample: [],
            errors
          };
        }
      }
    };
  }
});

// server/index.ts
import express2 from "express";
import path3 from "path";

// server/routes.ts
init_storage();
import { createServer } from "http";

// server/middleware/auth.ts
init_storage();

// server/services/auth.ts
init_storage();
init_email();
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
var JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
var AuthService = class {
  async login(email, password) {
    try {
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return { success: false, message: "E-mailadres niet gevonden. Controleer uw inloggegevens." };
      }
      if (!user.active) {
        return { success: false, message: "Dit account is uitgeschakeld. Neem contact op met de beheerder." };
      }
      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      if (!isValidPassword) {
        return { success: false, message: "Wachtwoord is niet correct. Probeer opnieuw." };
      }
      const token = this.generateToken(user.id);
      const { passwordHash, ...userWithoutPassword } = user;
      return {
        success: true,
        user: userWithoutPassword,
        token
      };
    } catch (error) {
      console.error("Login error:", error);
      return { success: false, message: "Inloggen mislukt. Probeer het later opnieuw." };
    }
  }
  generateToken(userId) {
    return jwt.sign({ userId }, JWT_SECRET, { expiresIn: "24h" });
  }
  verifyToken(token) {
    try {
      const decoded = jwt.verify(token, JWT_SECRET);
      return decoded;
    } catch (error) {
      return null;
    }
  }
  async hashPassword(password) {
    return bcrypt.hash(password, 12);
  }
  generateRandomPassword() {
    const length = 12;
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
    let password = "";
    for (let i = 0; i < length; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    return password;
  }
  async resetPassword(email) {
    try {
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return { success: false, message: "E-mailadres niet gevonden in het systeem." };
      }
      if (!user.active) {
        return { success: false, message: "Dit account is uitgeschakeld. Neem contact op met de beheerder." };
      }
      const newPassword = this.generateRandomPassword();
      const hashedPassword = await this.hashPassword(newPassword);
      await storage.updateUserPassword(user.id, hashedPassword);
      const emailContent = generatePasswordResetEmail(newPassword, user.email);
      const emailSent = await sendEmail({
        to: user.email,
        from: "noreply@idarah.be",
        // You can configure this
        subject: emailContent.subject,
        text: emailContent.text,
        html: emailContent.html
      });
      if (!emailSent) {
        console.error("Failed to send password reset email to:", user.email);
      }
      return { success: true, message: "Een nieuw wachtwoord is verzonden naar uw e-mailadres." };
    } catch (error) {
      console.error("Password reset error:", error);
      return { success: false, message: "Er is een fout opgetreden bij het resetten van uw wachtwoord." };
    }
  }
};
var authService = new AuthService();

// server/middleware/auth.ts
async function authMiddleware(req, res, next) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ message: "Inloggen vereist. Log eerst in." });
    }
    const token = authHeader.substring(7);
    const decoded = authService.verifyToken(token);
    if (!decoded) {
      return res.status(401).json({ message: "Uw sessie is verlopen. Log opnieuw in." });
    }
    const user = await storage.getUser(decoded.userId);
    if (!user || !user.active) {
      return res.status(401).json({ message: "Account niet gevonden. Neem contact op met de beheerder." });
    }
    req.user = user;
    req.tenantId = user.tenantId;
    next();
  } catch (error) {
    console.error("Auth middleware error:", error);
    res.status(401).json({ message: "Inloggen mislukt. Probeer opnieuw." });
  }
}

// server/middleware/tenant.ts
init_storage();
async function tenantMiddleware(req, res, next) {
  try {
    if (!req.tenantId) {
      return res.status(401).json({ message: "Geen tenant context" });
    }
    const tenant = await storage.getTenant(req.tenantId);
    if (!tenant) {
      return res.status(404).json({ message: "Tenant niet gevonden" });
    }
    next();
  } catch (error) {
    console.error("Tenant middleware error:", error);
    res.status(500).json({ message: "Tenant verificatie mislukt" });
  }
}

// server/middleware/quickAuth.ts
var verifyTokens = /* @__PURE__ */ new Map();
setInterval(() => {
  const now = /* @__PURE__ */ new Date();
  const tokensToDelete = [];
  verifyTokens.forEach((data, token) => {
    const hoursPassed = (now.getTime() - data.createdAt.getTime()) / (1e3 * 60 * 60);
    if (hoursPassed > 2) {
      tokensToDelete.push(token);
    }
  });
  tokensToDelete.forEach((token) => verifyTokens.delete(token));
}, 60 * 60 * 1e3);
var quickAuthMiddleware = (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ error: "Inloggen vereist. Log eerst in." });
    }
    const token = authHeader.substring(7);
    const tokenData = verifyTokens.get(token);
    if (!tokenData) {
      return res.status(401).json({ error: "Uw sessie is verlopen. Log opnieuw in." });
    }
    const now = /* @__PURE__ */ new Date();
    const hoursPassed = (now.getTime() - tokenData.createdAt.getTime()) / (1e3 * 60 * 60);
    if (hoursPassed > 2) {
      verifyTokens.delete(token);
      return res.status(401).json({ error: "Inlogtijd verlopen. Log opnieuw in." });
    }
    if (tokenData.role !== "BEHEERDER" && tokenData.role !== "MEDEWERKER") {
      return res.status(403).json({ error: "Onvoldoende rechten voor deze actie" });
    }
    req.user = {
      id: tokenData.userId,
      role: tokenData.role
    };
    next();
  } catch (error) {
    res.status(401).json({ error: "Inloggen mislukt. Probeer opnieuw." });
  }
};
var storeVerifyToken = (token, userId, role) => {
  verifyTokens.set(token, {
    userId,
    role,
    createdAt: /* @__PURE__ */ new Date()
  });
};

// server/services/member.ts
init_storage();
var MemberService = class {
  async checkForDuplicates(tenantId, memberData) {
    const result = { hasDuplicates: false };
    console.log("\u{1F50D} SERVICE - Checking duplicates for tenant:", tenantId, "memberNumber:", memberData.memberNumber);
    if (memberData.memberNumber) {
      const existingByNumber = await storage.getMemberByNumber(tenantId, memberData.memberNumber);
      console.log("\u{1F50D} SERVICE - Found existing member:", existingByNumber ? `ID: ${existingByNumber.id}, Number: ${existingByNumber.memberNumber}` : "NONE");
      if (existingByNumber) {
        result.hasDuplicates = true;
        result.duplicateNumber = existingByNumber;
        result.suggestedNumber = await storage.getNextAvailableMemberNumber(tenantId, memberData.memberNumber);
        console.log("\u{1F50D} SERVICE - DUPLICATE DETECTED! Suggested number:", result.suggestedNumber);
      }
    }
    if (memberData.street && memberData.number) {
      const existingByNameAddress = await storage.getMemberByNameAndAddress(
        tenantId,
        memberData.firstName,
        memberData.lastName,
        memberData.street,
        memberData.number
      );
      if (existingByNameAddress) {
        result.hasDuplicates = true;
        result.duplicateNameAddress = existingByNameAddress;
      }
    }
    return result;
  }
  async createMember(tenantId, memberData) {
    try {
      const memberNumber = await this.generateMemberNumber(tenantId);
      const { financialSettings, organization, permissions, ...memberFields } = memberData;
      const member = await storage.createMember({
        ...memberFields,
        tenantId,
        memberNumber,
        active: true
        // Nieuwe leden zijn standaard actief
      });
      if (memberData.financialSettings) {
        await storage.createMemberFinancialSettings({
          memberId: member.id,
          ...memberData.financialSettings
        });
      }
      if (memberData.permissions) {
        await storage.createMemberPermissions({
          memberId: member.id,
          ...memberData.permissions
        });
      }
      await this.generateInitialFee(member);
      return {
        success: true,
        member
      };
    } catch (error) {
      console.error("Error creating member:", error);
      return {
        success: false,
        message: "Fout bij het aanmaken van het lid"
      };
    }
  }
  async generateMemberNumber(tenantId) {
    const members2 = await storage.getMembersByTenant(tenantId);
    let maxNumber = 0;
    for (const member of members2) {
      const match = member.memberNumber.match(/^(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        if (num > maxNumber) {
          maxNumber = num;
        }
      }
    }
    const nextNumber = maxNumber + 1;
    return nextNumber.toString().padStart(4, "0");
  }
  async generateInitialFee(member) {
    try {
      const financialSettings = await storage.getMemberFinancialSettings(member.id);
      if (!financialSettings) {
        console.error(`No financial settings found for member ${member.id}`);
        return;
      }
      const now = /* @__PURE__ */ new Date();
      const periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
      let periodEnd;
      if (financialSettings.paymentTerm === "YEARLY") {
        periodEnd = new Date(periodStart);
        periodEnd.setFullYear(periodEnd.getFullYear() + 1);
        periodEnd.setDate(periodEnd.getDate() - 1);
      } else {
        periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);
      }
      const tenant = await storage.getTenantById(member.tenantId);
      if (!tenant) {
        console.error(`No tenant found for member ${member.id}`);
        return;
      }
      let yearlyAmount = parseFloat(tenant.adultFee || "25.00");
      if (member.category === "STUDENT") yearlyAmount = parseFloat(tenant.studentFee || "15.00");
      if (member.category === "SENIOR") yearlyAmount = parseFloat(tenant.seniorFee || "20.00");
      let amount;
      if (financialSettings.paymentTerm === "YEARLY") {
        amount = yearlyAmount;
      } else {
        amount = yearlyAmount / 12;
      }
      await storage.createMembershipFee({
        tenantId: member.tenantId,
        memberId: member.id,
        memberNumber: member.memberNumber,
        memberName: `${member.firstName} ${member.lastName}`,
        periodStart,
        periodEnd,
        amount: amount.toString(),
        status: "OPEN"
      });
    } catch (error) {
      console.error("Error generating initial fee for member:", error);
      throw error;
    }
  }
};
var memberService = new MemberService();

// server/services/fee.ts
init_storage();
var FeeService = class {
  async markFeePaid(feeId, tenantId) {
    try {
      const fee = await storage.getMembershipFee(feeId);
      if (!fee || fee.tenantId !== tenantId) {
        return {
          success: false,
          message: "Lidgeld niet gevonden"
        };
      }
      if (fee.status === "PAID") {
        return {
          success: false,
          message: "Lidgeld is al betaald"
        };
      }
      const updatedFee = await storage.updateMembershipFee(feeId, {
        status: "PAID",
        paidAt: /* @__PURE__ */ new Date(),
        method: "OVERSCHRIJVING"
        // Default payment method
      });
      await storage.createTransaction({
        tenantId,
        memberId: fee.memberId,
        type: "INCOME",
        category: "Lidgeld",
        amount: fee.amount,
        date: /* @__PURE__ */ new Date(),
        method: "OVERSCHRIJVING",
        description: `Lidgeld betaling voor periode ${fee.periodStart.toLocaleDateString("nl-BE")} - ${fee.periodEnd.toLocaleDateString("nl-BE")}`,
        relatedFeeId: feeId
      });
      return {
        success: true,
        fee: updatedFee
      };
    } catch (error) {
      console.error("Error marking fee as paid:", error);
      return {
        success: false,
        message: "Fout bij het markeren van lidgeld als betaald"
      };
    }
  }
};
var feeService = new FeeService();

// server/services/financial.ts
init_storage();
var FinancialService = class {
  async generateReports(tenantId) {
    try {
      const transactions2 = await storage.getTransactionsByTenant(tenantId);
      const fees = await storage.getMembershipFeesByTenant(tenantId);
      const monthlyRevenue = this.calculateMonthlyRevenue(transactions2);
      const paymentStatus = this.calculatePaymentStatus(fees);
      const categoryBreakdown = this.calculateCategoryBreakdown(transactions2);
      return {
        monthlyRevenue,
        paymentStatus,
        categoryBreakdown
      };
    } catch (error) {
      console.error("Error generating financial reports:", error);
      throw error;
    }
  }
  calculateMonthlyRevenue(transactions2) {
    const monthlyData = {};
    transactions2.filter((t) => t.type === "INCOME").forEach((transaction) => {
      const month = new Date(transaction.date).toISOString().slice(0, 7);
      monthlyData[month] = (monthlyData[month] || 0) + parseFloat(transaction.amount);
    });
    return Object.entries(monthlyData).map(([month, amount]) => ({ month, amount })).sort((a, b) => a.month.localeCompare(b.month)).slice(-12);
  }
  calculatePaymentStatus(fees) {
    const statusData = {};
    fees.forEach((fee) => {
      const status = fee.status;
      if (!statusData[status]) {
        statusData[status] = { count: 0, amount: 0 };
      }
      statusData[status].count++;
      statusData[status].amount += parseFloat(fee.amount);
    });
    return Object.entries(statusData).map(([status, data]) => ({
      status,
      count: data.count,
      amount: data.amount
    }));
  }
  calculateCategoryBreakdown(transactions2) {
    const categoryData = {};
    transactions2.forEach((transaction) => {
      const category = transaction.category;
      categoryData[category] = (categoryData[category] || 0) + parseFloat(transaction.amount);
    });
    return Object.entries(categoryData).map(([category, amount]) => ({
      category,
      amount
    }));
  }
};
var financialService = new FinancialService();

// server/services/card.ts
init_storage();
init_status();
import { createHash, randomBytes as randomBytes2 } from "crypto";
var CardService = class {
  /**
   * Generate a secure token for card operations
   */
  generateSecureToken() {
    return randomBytes2(32).toString("hex");
  }
  /**
   * Calculate ETag based on member data and tenant branding version
   */
  calculateETag(member, tenant) {
    const data = {
      memberNumber: member.memberNumber,
      firstName: member.firstName,
      lastName: member.lastName,
      category: member.category,
      active: member.active,
      // Add tenant branding version when available
      brandingVersion: 1
      // tenant.brandingVersion || 1
    };
    return createHash("sha256").update(JSON.stringify(data)).digest("hex").substring(0, 16);
  }
  /**
   * Get or create card metadata for a member
   */
  async getOrCreateCardMeta(memberId) {
    try {
      let cardData = await storage.getMemberWithCardAndTenant(memberId);
      if (cardData) {
        const currentETag = this.calculateETag(cardData.member, cardData.tenant);
        if (cardData.cardMeta.etag !== currentETag) {
          const updatedCardMeta = await this.invalidateCard(cardData.cardMeta.id, currentETag);
          cardData.cardMeta = updatedCardMeta;
        }
        return cardData;
      }
      const member = await storage.getMember(memberId);
      if (!member) return null;
      const tenant = await storage.getTenant(member.tenantId);
      if (!tenant) return null;
      const etag = this.calculateETag(member, tenant);
      const newCardMeta = await storage.createCardMeta({
        tenantId: member.tenantId,
        memberId: member.id,
        version: 1,
        etag,
        secureToken: this.generateSecureToken(),
        qrToken: this.generateSecureToken(),
        status: "ACTUEEL",
        validUntil: new Date((/* @__PURE__ */ new Date()).getFullYear(), 11, 31)
        // End of current year
      });
      return { member, cardMeta: newCardMeta, tenant };
    } catch (error) {
      console.error("Error in getOrCreateCardMeta:", error);
      return null;
    }
  }
  /**
   * Invalidate a card by bumping version and rotating tokens
   */
  async invalidateCard(cardId, newETag) {
    const existingCard = await storage.getCardMetaByMember(cardId);
    if (!existingCard) {
      throw new Error("Card not found");
    }
    const updates = {
      version: existingCard.version + 1,
      etag: newETag || existingCard.etag,
      secureToken: this.generateSecureToken(),
      qrToken: this.generateSecureToken(),
      status: "ACTUEEL",
      lastRenderedAt: /* @__PURE__ */ new Date()
    };
    return await storage.updateCardMeta(existingCard.id, updates);
  }
  /**
   * Verify card using QR token
   */
  async verifyCardByQrToken(qrToken) {
    try {
      const cardMeta2 = await storage.getCardMetaByQrToken(qrToken);
      if (!cardMeta2) return null;
      const member = await storage.getMember(cardMeta2.memberId);
      if (!member) return null;
      const tenant = await storage.getTenant(cardMeta2.tenantId);
      if (!tenant) return null;
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      const memberFees = await storage.getMembershipFeesByMember(member.id);
      const currentYearFees = memberFees.filter((fee) => {
        const feeYear = new Date(fee.periodStart).getFullYear();
        return feeYear === currentYear;
      });
      const currentYearPaid = currentYearFees.some((fee) => fee.status === "PAID");
      return {
        ok: true,
        member: {
          naam: `${member.firstName} ${member.lastName}`,
          nummer: member.memberNumber
        },
        status: {
          actief: member.active,
          betaaldDitJaar: currentYearPaid,
          geldigTot: cardMeta2.validUntil?.toISOString().split("T")[0] || null
        },
        tenant: {
          naam: tenant.name,
          slug: tenant.slug
        },
        ts: Date.now()
      };
    } catch (error) {
      console.error("Error in verifyCardByQrToken:", error);
      return null;
    }
  }
  /**
   * Get card data for display
   */
  async getCardData(memberId) {
    return await this.getOrCreateCardMeta(memberId);
  }
  /**
   * Recalculate card status based on member data and payments
   */
  async recalculateCardStatus(memberId, tenantId) {
    try {
      const cardMeta2 = await storage.getCardMetaByMember(memberId);
      if (!cardMeta2 || cardMeta2.tenantId !== tenantId) {
        console.warn(`Card not found for member ${memberId} in tenant ${tenantId}`);
        return;
      }
      const newStatus = await computeCardStatus(memberId);
      await storage.updateCardMeta(cardMeta2.id, {
        status: newStatus
      });
      console.log(`Updated card status for member ${memberId} to ${newStatus}`);
    } catch (error) {
      console.error(`Error recalculating card status for member ${memberId}:`, error);
      throw error;
    }
  }
};
var cardService = new CardService();

// server/services/ruleService.ts
init_db();
init_schema();
import { eq as eq3, and as and4 } from "drizzle-orm";
var RuleService = class {
  /**
   * Evaluate voting rights for a member
   */
  async evaluateVotingRights(memberId, tenantId) {
    const [member] = await db.select().from(members).where(and4(eq3(members.id, memberId), eq3(members.tenantId, tenantId)));
    if (!member) {
      return {
        eligible: false,
        hasOverride: false,
        warnings: ["Lid niet gevonden"]
      };
    }
    const [override] = await db.select().from(ruleOverrides).where(and4(
      eq3(ruleOverrides.memberId, memberId),
      eq3(ruleOverrides.tenantId, tenantId),
      eq3(ruleOverrides.ruleScope, "STEMRECHT"),
      eq3(ruleOverrides.active, true)
    ));
    if (override) {
      return {
        eligible: override.overrideValue,
        hasOverride: true,
        override,
        warnings: override.overrideValue ? ["Stemrecht handmatig toegekend"] : ["Stemrecht handmatig ingetrokken"]
      };
    }
    const votingRules = await db.select().from(rules).where(and4(
      eq3(rules.tenantId, tenantId),
      eq3(rules.scope, "STEMRECHT"),
      eq3(rules.active, true)
    ));
    const violatedRules = [];
    const warnings = [];
    if (votingRules.length === 0) {
      const defaultResult = this.applyDefaultVotingRules(member);
      if (!defaultResult.eligible) {
        warnings.push(...defaultResult.warnings || []);
      }
      return defaultResult;
    }
    for (const rule of votingRules) {
      const config = rule.parameters;
      const ruleResult = this.evaluateVotingRule(member, config);
      if (!ruleResult.eligible) {
        violatedRules.push(rule);
        warnings.push(...ruleResult.warnings || []);
      }
    }
    const eligible = violatedRules.length === 0;
    return {
      eligible,
      hasOverride: false,
      violatedRules,
      warnings: warnings.length > 0 ? warnings : void 0
    };
  }
  /**
   * Apply default voting rights rules (Dutch/Belgian mosque standards)
   */
  applyDefaultVotingRules(member) {
    const warnings = [];
    let eligible = true;
    if (!member.active) {
      eligible = false;
      warnings.push("Lid is niet actief");
    }
    if (member.birthDate) {
      const age = this.calculateAge(member.birthDate);
      if (age < 18) {
        eligible = false;
        warnings.push("Lid is jonger dan 18 jaar");
      }
    }
    if (member.category === "STUDENT" || member.category === "JEUGD") {
      eligible = false;
      warnings.push("Studenten en jeugdleden hebben geen stemrecht");
    }
    return {
      eligible,
      hasOverride: false,
      warnings: warnings.length > 0 ? warnings : void 0
    };
  }
  /**
   * Evaluate a specific voting rule
   */
  evaluateVotingRule(member, config) {
    const warnings = [];
    let eligible = true;
    if (member.birthDate) {
      const age = this.calculateAge(member.birthDate);
      if (config.minAge && age < config.minAge) {
        eligible = false;
        warnings.push(`Lid is jonger dan vereiste minimumleeftijd (${config.minAge})`);
      }
      if (config.maxAge && age > config.maxAge) {
        eligible = false;
        warnings.push(`Lid is ouder dan vereiste maximumleeftijd (${config.maxAge})`);
      }
    }
    if (config.allowedCategories && !config.allowedCategories.includes(member.category)) {
      eligible = false;
      warnings.push(`Lidcategorie '${member.category}' heeft geen stemrecht`);
    }
    if (config.excludedCategories && config.excludedCategories.includes(member.category)) {
      eligible = false;
      warnings.push(`Lidcategorie '${member.category}' is uitgesloten van stemrecht`);
    }
    if (config.requireActiveMembership && !member.active) {
      eligible = false;
      warnings.push("Actief lidmaatschap is vereist voor stemrecht");
    }
    return {
      eligible,
      hasOverride: false,
      warnings: warnings.length > 0 ? warnings : void 0
    };
  }
  /**
   * Create or update a rule override
   */
  async createRuleOverride(memberId, tenantId, ruleScope, overrideValue, reason, overriddenBy) {
    await db.update(ruleOverrides).set({ active: false }).where(and4(
      eq3(ruleOverrides.memberId, memberId),
      eq3(ruleOverrides.tenantId, tenantId),
      eq3(ruleOverrides.ruleScope, ruleScope)
    ));
    const [override] = await db.insert(ruleOverrides).values({
      tenantId,
      memberId,
      ruleScope,
      overrideValue,
      reason,
      overriddenBy
    }).returning();
    return override;
  }
  /**
   * Check if member has voting rights (with override support)
   */
  async hasVotingRights(memberId, tenantId) {
    const result = await this.evaluateVotingRights(memberId, tenantId);
    return result.eligible;
  }
  /**
   * Get detailed voting rights status for display
   */
  async getVotingRightsStatus(memberId, tenantId) {
    const result = await this.evaluateVotingRights(memberId, tenantId);
    let reason = "";
    if (result.hasOverride) {
      reason = result.override?.overrideValue ? `Handmatig toegekend: ${result.override.reason}` : `Handmatig ingetrokken: ${result.override.reason}`;
    } else if (result.eligible) {
      reason = "Voldoet aan alle voorwaarden";
    } else {
      reason = result.warnings?.join("; ") || "Voldoet niet aan voorwaarden";
    }
    return {
      eligible: result.eligible,
      hasOverride: result.hasOverride,
      reason,
      warnings: result.warnings || []
    };
  }
  /**
   * Calculate age from birth date
   */
  calculateAge(birthDate) {
    const birth = new Date(birthDate);
    const today = /* @__PURE__ */ new Date();
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (monthDiff < 0 || monthDiff === 0 && today.getDate() < birth.getDate()) {
      age--;
    }
    return age;
  }
};
var ruleService = new RuleService();

// server/services/board.ts
init_db();
init_schema();
import { eq as eq4, and as and5, desc as desc3, isNull } from "drizzle-orm";
var BoardService = class {
  async listBoardMembers(tenantId, filters) {
    let whereConditions = [eq4(boardMembers.tenantId, tenantId)];
    if (filters?.status) {
      whereConditions.push(eq4(boardMembers.status, filters.status));
    }
    if (filters?.role) {
      whereConditions.push(eq4(boardMembers.role, filters.role));
    }
    return await db.select({
      boardMember: boardMembers,
      member: members
    }).from(boardMembers).leftJoin(members, eq4(boardMembers.memberId, members.id)).where(and5(...whereConditions)).orderBy(boardMembers.orderIndex, boardMembers.role);
  }
  async getBoardMember(tenantId, id) {
    const result = await db.select({
      boardMember: boardMembers,
      member: members,
      terms: boardTerms
    }).from(boardMembers).leftJoin(members, eq4(boardMembers.memberId, members.id)).leftJoin(boardTerms, eq4(boardTerms.boardMemberId, boardMembers.id)).where(and5(
      eq4(boardMembers.tenantId, tenantId),
      eq4(boardMembers.id, id)
    )).orderBy(desc3(boardTerms.start));
    if (result.length === 0) return null;
    const boardMember = result[0].boardMember;
    const member = result[0].member;
    const terms = result.map((r) => r.terms).filter(Boolean);
    return {
      ...boardMember,
      member,
      terms
    };
  }
  async createBoardMember(tenantId, data) {
    const boardMember = await db.insert(boardMembers).values({ ...data, tenantId }).returning();
    if (boardMember[0]) {
      await db.insert(boardTerms).values({
        tenantId,
        boardMemberId: boardMember[0].id,
        role: data.role,
        start: data.termStart,
        end: data.termEnd || null
      });
    }
    return boardMember[0];
  }
  async updateBoardMember(tenantId, id, data) {
    const updated = await db.update(boardMembers).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(and5(
      eq4(boardMembers.tenantId, tenantId),
      eq4(boardMembers.id, id)
    )).returning();
    return updated[0];
  }
  async endActiveTerm(tenantId, boardMemberId, endDate, note) {
    await db.update(boardTerms).set({ end: endDate, note }).where(and5(
      eq4(boardTerms.tenantId, tenantId),
      eq4(boardTerms.boardMemberId, boardMemberId),
      isNull(boardTerms.end)
    ));
    await db.update(boardMembers).set({ status: "INACTIEF", termEnd: endDate, updatedAt: /* @__PURE__ */ new Date() }).where(and5(
      eq4(boardMembers.tenantId, tenantId),
      eq4(boardMembers.id, boardMemberId)
    ));
    return true;
  }
  async reorderBoard(tenantId, orderData) {
    for (const item of orderData) {
      await db.update(boardMembers).set({ orderIndex: item.orderIndex, updatedAt: /* @__PURE__ */ new Date() }).where(and5(
        eq4(boardMembers.tenantId, tenantId),
        eq4(boardMembers.id, item.id)
      ));
    }
    return true;
  }
  async getActiveBoardMemberByMemberId(tenantId, memberId) {
    const result = await db.select().from(boardMembers).where(and5(
      eq4(boardMembers.tenantId, tenantId),
      eq4(boardMembers.memberId, memberId),
      eq4(boardMembers.status, "ACTIEF")
    )).limit(1);
    return result[0] || null;
  }
  async getBoardMemberByMemberId(tenantId, memberId) {
    const whereConditions = [eq4(boardMembers.memberId, memberId)];
    if (tenantId) {
      whereConditions.push(eq4(boardMembers.tenantId, tenantId));
    }
    const result = await db.select({
      boardMember: boardMembers,
      member: members
    }).from(boardMembers).leftJoin(members, eq4(boardMembers.memberId, members.id)).where(and5(...whereConditions)).limit(1);
    return result[0] || null;
  }
};
var boardService = new BoardService();

// server/lib/card/etag.ts
import { createHash as createHash2 } from "crypto";
function makeCardETag(memberData, tenantBranding, cardStatus, validUntil, badges, version) {
  const cardDataString = JSON.stringify({
    member: {
      id: memberData.id,
      firstName: memberData.firstName,
      lastName: memberData.lastName,
      memberNumber: memberData.memberNumber,
      category: memberData.category,
      votingRights: memberData.votingRights
    },
    tenant: {
      name: tenantBranding.name,
      logoUrl: tenantBranding.logoUrl,
      primaryColor: tenantBranding.primaryColor
    },
    status: cardStatus,
    validUntil: validUntil?.toISOString() || null,
    badges: badges.sort(),
    // Sort badges for consistent ordering
    version: version || 1,
    // Include timestamp rounded to hour to force refresh periodically
    timeGroup: Math.floor(Date.now() / (1e3 * 60 * 60))
  });
  const hash = createHash2("sha256").update(cardDataString).digest("hex").substring(0, 12);
  return `"${hash}"`;
}

// server/routes.ts
init_status();
init_schema();
init_db();
import { randomBytes as randomBytes3 } from "crypto";
import { eq as eq8 } from "drizzle-orm";

// server/api/jobs/fees/generate.ts
import { z as z2 } from "zod";

// lib/server/fees/generator.ts
init_db();
init_schema();
import { eq as eq5, and as and6 } from "drizzle-orm";
async function generateTenantFees(tenantId, asOf, strategy = "current") {
  console.log(`Generating fees for tenant ${tenantId} as of ${asOf.toISOString()} with strategy: ${strategy}`);
  try {
    const membersWithSettings = await db.select({
      member: members,
      settings: memberFinancialSettings
    }).from(members).leftJoin(memberFinancialSettings, eq5(members.id, memberFinancialSettings.memberId)).where(and6(
      eq5(members.tenantId, tenantId),
      eq5(members.active, true)
    ));
    let feesGenerated = 0;
    for (const { member, settings } of membersWithSettings) {
      if (!settings) {
        console.log(`Skipping member ${member.id} - no financial settings`);
        continue;
      }
      try {
        const generated = await generateMemberFees(member.id, settings, asOf, strategy);
        feesGenerated += generated;
      } catch (error) {
        console.error(`Error generating fees for member ${member.id}:`, error);
      }
    }
    console.log(`Generated ${feesGenerated} fees for tenant ${tenantId}`);
  } catch (error) {
    console.error("Error in generateTenantFees:", error);
    throw error;
  }
}
async function generateMemberFees(memberId, settings, asOf, strategy) {
  const billingAnchor = new Date(settings.billingAnchorAt);
  const amount = settings.preferredTerm === "YEARLY" ? parseFloat(settings.yearlyAmount) : parseFloat(settings.monthlyAmount);
  if (amount <= 0) {
    console.log(`Skipping member ${memberId} - zero amount`);
    return 0;
  }
  const existingFees = await db.select().from(membershipFees).where(eq5(membershipFees.memberId, memberId));
  const periodsToGenerate = calculatePeriodsToGenerate(
    billingAnchor,
    asOf,
    settings.preferredTerm,
    existingFees,
    strategy
  );
  let generated = 0;
  for (const period of periodsToGenerate) {
    const [member] = await db.select().from(members).where(eq5(members.id, memberId));
    if (!member) throw new Error(`Member ${memberId} not found`);
    await db.insert(membershipFees).values({
      tenantId: member.tenantId,
      memberId,
      memberNumber: member.memberNumber,
      memberName: `${member.firstName} ${member.lastName}`,
      amount: amount.toString(),
      status: "OPEN",
      periodStart: period.start,
      periodEnd: period.end
    });
    generated++;
  }
  return generated;
}
function calculatePeriodsToGenerate(anchor, asOf, term, existingFees, strategy) {
  const periods = [];
  const current = new Date(anchor);
  const existingStarts = new Set(
    existingFees.map((fee) => new Date(fee.periodStart).getTime())
  );
  while (current <= asOf) {
    const periodStart = new Date(current);
    const periodEnd = new Date(current);
    if (term === "MONTHLY") {
      periodEnd.setMonth(periodEnd.getMonth() + 1);
    } else {
      periodEnd.setFullYear(periodEnd.getFullYear() + 1);
    }
    periodEnd.setDate(periodEnd.getDate() - 1);
    if (!existingStarts.has(periodStart.getTime())) {
      periods.push({ start: periodStart, end: periodEnd });
    }
    if (term === "MONTHLY") {
      current.setMonth(current.getMonth() + 1);
    } else {
      current.setFullYear(current.getFullYear() + 1);
    }
  }
  return periods;
}

// lib/server/time.ts
function beNow() {
  return /* @__PURE__ */ new Date();
}

// server/api/jobs/fees/generate.ts
var generateFeesSchema = z2.object({
  tenantId: z2.string().optional(),
  asOf: z2.string().optional().transform((val) => val ? new Date(val) : void 0),
  strategy: z2.enum(["current", "catchup"]).default("current")
});
async function generateFeesHandler(req, res) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ error: "Missing or invalid authorization header" });
    }
    const body = generateFeesSchema.parse(req.body);
    const { tenantId, asOf, strategy } = body;
    const targetTenantId = tenantId || req.tenantId;
    if (!targetTenantId) {
      return res.status(400).json({ error: "tenantId is required" });
    }
    const currentTime = asOf || beNow();
    await generateTenantFees(targetTenantId, currentTime, strategy);
    res.json({
      success: true,
      message: `Fees generated successfully for tenant ${targetTenantId}`,
      strategy,
      asOf: currentTime.toISOString()
    });
  } catch (error) {
    console.error("Fee generation error:", error);
    if (error instanceof z2.ZodError) {
      return res.status(400).json({
        error: "Validation error",
        details: error.errors
      });
    }
    res.status(500).json({
      error: "Internal server error",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
}

// server/api/members/create.ts
init_db();
init_schema();
import { z as z3 } from "zod";
import { eq as eq7 } from "drizzle-orm";

// lib/server/fees/first-fee.ts
init_db();
init_schema();
import { eq as eq6 } from "drizzle-orm";
async function createFirstFeeForMember(memberId, joinDate) {
  try {
    const [settings] = await db.select().from(memberFinancialSettings).where(eq6(memberFinancialSettings.memberId, memberId));
    if (!settings) {
      throw new Error(`No financial settings found for member ${memberId}`);
    }
    const anchorDate = joinDate || /* @__PURE__ */ new Date();
    const amount = settings.preferredTerm === "YEARLY" ? parseFloat(settings.yearlyAmount) : parseFloat(settings.monthlyAmount);
    const [member] = await db.select().from(members).where(eq6(members.id, memberId));
    if (!member) {
      throw new Error(`Member ${memberId} not found`);
    }
    await db.insert(membershipFees).values({
      tenantId: member.tenantId,
      memberId,
      memberNumber: member.memberNumber,
      memberName: `${member.firstName} ${member.lastName}`,
      amount: amount.toString(),
      status: "OPEN",
      periodStart: anchorDate,
      periodEnd: getNextPeriodEnd(anchorDate, settings.preferredTerm)
    });
  } catch (error) {
    console.error("Error creating first fee:", error);
    throw error;
  }
}
function getNextPeriodEnd(startDate, term) {
  const endDate = new Date(startDate);
  if (term === "MONTHLY") {
    endDate.setMonth(endDate.getMonth() + 1);
  } else {
    endDate.setFullYear(endDate.getFullYear() + 1);
  }
  endDate.setDate(endDate.getDate() - 1);
  return endDate;
}

// server/api/members/create.ts
var createMemberSchema = z3.object({
  memberNumber: z3.string(),
  firstName: z3.string(),
  lastName: z3.string(),
  gender: z3.enum(["M", "V"]),
  birthDate: z3.string().optional().transform((val) => val ? new Date(val) : void 0),
  category: z3.enum(["STUDENT", "VOLWASSEN", "SENIOR"]),
  email: z3.string().email().optional(),
  phone: z3.string().optional(),
  street: z3.string().optional(),
  number: z3.string().optional(),
  postalCode: z3.string().optional(),
  city: z3.string().optional(),
  country: z3.string().optional(),
  joinDate: z3.string().optional().transform((val) => val ? new Date(val) : void 0),
  // Financial settings
  preferredMethod: z3.enum(["SEPA", "OVERSCHRIJVING", "BANCONTACT", "CASH"]),
  preferredTerm: z3.enum(["MONTHLY", "YEARLY"]),
  monthlyAmount: z3.number().default(0),
  yearlyAmount: z3.number().default(0),
  iban: z3.string().optional(),
  sepaMandate: z3.string().optional()
});
async function createMemberHandler(req, res) {
  try {
    const tenantId = req.tenantId;
    if (!tenantId) {
      return res.status(400).json({ error: "Tenant context required" });
    }
    const body = createMemberSchema.parse(req.body);
    const joinDate = body.joinDate || beNow();
    const result = await db.transaction(async (tx) => {
      const [member] = await tx.insert(members).values({
        tenantId,
        memberNumber: body.memberNumber,
        firstName: body.firstName,
        lastName: body.lastName,
        gender: body.gender,
        birthDate: body.birthDate,
        category: body.category,
        email: body.email,
        phone: body.phone,
        street: body.street,
        number: body.number,
        postalCode: body.postalCode,
        city: body.city,
        country: body.country,
        active: true
      }).returning();
      const tenant = await tx.select().from(tenants).where(eq7(tenants.id, tenantId)).limit(1);
      const tenantData = tenant[0];
      let yearlyAmount = parseFloat(tenantData?.adultFee || "25.00");
      if (body.category === "STUDENT") yearlyAmount = parseFloat(tenantData?.studentFee || "15.00");
      if (body.category === "SENIOR") yearlyAmount = parseFloat(tenantData?.seniorFee || "20.00");
      const monthlyAmount = yearlyAmount / 12;
      await tx.insert(memberFinancialSettings).values({
        memberId: member.id,
        paymentMethod: body.preferredMethod,
        paymentTerm: body.preferredTerm,
        monthlyAmount: monthlyAmount.toString(),
        yearlyAmount: yearlyAmount.toString(),
        iban: body.iban
      });
      return member;
    });
    try {
      await createFirstFeeForMember(result.id, joinDate);
    } catch (feeError) {
      console.error("Failed to create first fee:", feeError);
    }
    res.status(201).json({
      success: true,
      member: result,
      message: "Member created successfully with first fee"
    });
  } catch (error) {
    console.error("Member creation error:", error);
    if (error instanceof z3.ZodError) {
      return res.status(400).json({
        error: "Validation error",
        details: error.errors
      });
    }
    res.status(500).json({
      error: "Internal server error",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
}

// server/routes/public-screens.ts
init_storage();
import { Router } from "express";
import { z as z4 } from "zod";
var router = Router();
router.get("/", authMiddleware, tenantMiddleware, async (req, res) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    const screens = await storage.getPublicScreensByTenant(tenantId);
    res.json(screens);
  } catch (error) {
    console.error("Error fetching public screens:", error);
    res.status(500).json({ error: "Failed to fetch public screens" });
  }
});
router.get("/token/:token", async (req, res) => {
  try {
    const screen = await storage.getPublicScreenByToken(req.params.token);
    if (!screen) {
      return res.status(404).json({ error: "Screen not found" });
    }
    if (!screen.active) {
      return res.status(403).json({
        error: "Screen inactive",
        message: "Dit scherm is momenteel niet actief",
        type: screen.type
      });
    }
    let screenData = screen;
    if (screen.type === "LEDENLIJST") {
      try {
        console.log(`Fetching members for tenant: ${screen.tenantId}`);
        const members2 = await storage.getMembersByTenant(screen.tenantId);
        console.log(`Found ${members2.length} total members`);
        const activeMembers = members2.filter((member) => member.active);
        console.log(`Found ${activeMembers.length} active members for public display`);
        const allFees = await storage.getMembershipFeesByTenant(screen.tenantId);
        console.log(`Found ${allFees.length} membership fees`);
        const feesByMember = allFees.reduce((acc, fee) => {
          if (!acc[fee.memberId]) acc[fee.memberId] = [];
          acc[fee.memberId].push(fee);
          return acc;
        }, {});
        const membersWithPayments = activeMembers.map((member) => ({
          ...member,
          membershipFees: feesByMember[member.id] || []
        }));
        screenData = {
          ...screen,
          members: membersWithPayments
        };
      } catch (error) {
        console.error("Error fetching members for public screen:", error);
      }
    }
    res.json(screenData);
  } catch (error) {
    console.error("Error fetching public screen:", error);
    res.status(500).json({ error: "Failed to fetch public screen" });
  }
});
router.post("/", authMiddleware, tenantMiddleware, async (req, res) => {
  try {
    const createSchema = z4.object({
      name: z4.string().min(1),
      type: z4.enum(["LEDENLIJST", "MEDEDELINGEN", "MULTIMEDIA"]),
      active: z4.boolean(),
      config: z4.any().default({})
    });
    const data = createSchema.parse(req.body);
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    const screenData = {
      ...data,
      tenantId,
      publicToken: `screen-${Math.random().toString(36).substring(2, 15)}`,
      config: data.config || {}
    };
    const screen = await storage.createPublicScreen(screenData);
    res.status(201).json(screen);
  } catch (error) {
    console.error("Error creating public screen:", error);
    if (error instanceof z4.ZodError) {
      return res.status(400).json({ error: "Invalid data", details: error.errors });
    }
    res.status(500).json({ error: "Failed to create public screen" });
  }
});
router.patch("/:id", authMiddleware, tenantMiddleware, async (req, res) => {
  try {
    const updateSchema = z4.object({
      name: z4.string().min(1).optional(),
      active: z4.boolean().optional(),
      config: z4.any().optional()
    });
    const data = updateSchema.parse(req.body);
    const screen = await storage.updatePublicScreen(req.params.id, data);
    res.json(screen);
  } catch (error) {
    console.error("Error updating public screen:", error);
    if (error instanceof z4.ZodError) {
      return res.status(400).json({ error: "Invalid data", details: error.errors });
    }
    res.status(500).json({ error: "Failed to update public screen" });
  }
});
router.put("/:id", authMiddleware, tenantMiddleware, async (req, res) => {
  try {
    const updateSchema = z4.object({
      name: z4.string().min(1).optional(),
      active: z4.boolean().optional(),
      config: z4.any().optional()
    });
    const data = updateSchema.parse(req.body);
    const screen = await storage.updatePublicScreen(req.params.id, data);
    res.json(screen);
  } catch (error) {
    console.error("Error updating public screen:", error);
    if (error instanceof z4.ZodError) {
      return res.status(400).json({ error: "Invalid data", details: error.errors });
    }
    res.status(500).json({ error: "Failed to update public screen" });
  }
});
router.delete("/:id", authMiddleware, tenantMiddleware, async (req, res) => {
  try {
    await storage.deletePublicScreen(req.params.id);
    res.status(204).send();
  } catch (error) {
    console.error("Error deleting public screen:", error);
    res.status(500).json({ error: "Failed to delete public screen" });
  }
});
var public_screens_default = router;

// server/routes.ts
import { z as z7 } from "zod";
import * as XLSX from "xlsx";
var loginSchema = z7.object({
  email: z7.string().email(),
  password: z7.string().min(1)
});
var createMemberSchema2 = z7.object({
  firstName: z7.string(),
  lastName: z7.string(),
  gender: z7.enum(["M", "V"]),
  birthDate: z7.union([z7.date(), z7.string().transform((str) => new Date(str))]),
  category: z7.enum(["STUDENT", "STANDAARD", "SENIOR"]),
  email: z7.string().optional(),
  phone: z7.string().optional(),
  street: z7.string(),
  number: z7.string(),
  bus: z7.string().optional(),
  postalCode: z7.string(),
  city: z7.string(),
  country: z7.string(),
  financialSettings: z7.object({
    paymentMethod: z7.enum(["SEPA", "OVERSCHRIJVING", "BANCONTACT", "CASH"]),
    iban: z7.string().optional(),
    paymentTerm: z7.enum(["MONTHLY", "YEARLY"])
  }),
  organization: z7.object({
    interestedInActiveRole: z7.boolean(),
    roleDescription: z7.string().optional()
  }),
  permissions: z7.object({
    privacyAgreement: z7.boolean(),
    photoVideoConsent: z7.boolean(),
    newsletterSubscription: z7.boolean(),
    whatsappList: z7.boolean()
  })
});
async function registerRoutes(app2) {
  app2.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = loginSchema.parse(req.body);
      const result = await authService.login(email, password);
      if (!result.success) {
        return res.status(401).json({ message: result.message });
      }
      res.json({
        user: result.user,
        token: result.token
      });
    } catch (error) {
      res.status(400).json({ message: "Invalid request" });
    }
  });
  app2.post("/api/auth/logout", authMiddleware, async (req, res) => {
    res.json({ message: "Logged out successfully" });
  });
  app2.get("/api/auth/me", authMiddleware, async (req, res) => {
    res.json({ user: req.user });
  });
  app2.post("/api/auth/reset-password", async (req, res) => {
    try {
      const { email } = z7.object({
        email: z7.string().email()
      }).parse(req.body);
      const result = await authService.resetPassword(email);
      if (!result.success) {
        return res.status(404).json({ message: result.message });
      }
      res.json({ message: "Een nieuw wachtwoord is verzonden naar uw e-mailadres." });
    } catch (error) {
      console.error("Password reset error:", error);
      res.status(400).json({ message: "Ongeldig e-mailadres" });
    }
  });
  app2.post("/api/auth/quick-verify", async (req, res) => {
    try {
      const { email, password } = loginSchema.parse(req.body);
      const result = await authService.login(email, password);
      if (!result.success) {
        return res.status(401).json({ error: "Ongeldige inloggegevens" });
      }
      const user = result.user;
      if (user.role !== "BEHEERDER" && user.role !== "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang - alleen medewerkers en beheerders" });
      }
      const verifyToken = `verify_${Date.now()}_${user.id}`;
      storeVerifyToken(verifyToken, user.id, user.role);
      res.json({
        user: {
          id: user.id,
          name: user.name,
          role: user.role
        },
        token: verifyToken
      });
    } catch (error) {
      res.status(400).json({ error: "Ongeldige aanvraag" });
    }
  });
  app2.put("/api/profile", authMiddleware, async (req, res) => {
    try {
      const { name, email } = req.body;
      if (!name || !email) {
        return res.status(400).json({ message: "Naam en email zijn verplicht" });
      }
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser && req.user && existingUser.id !== req.user.id) {
        return res.status(409).json({ message: "Dit email adres is al in gebruik" });
      }
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const updatedUser = await storage.updateUser(req.user.id, { name, email });
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Er is een fout opgetreden bij het bijwerken van uw profiel" });
    }
  });
  app2.put("/api/profile/password", authMiddleware, async (req, res) => {
    try {
      const { currentPassword, newPassword } = req.body;
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Huidig en nieuw wachtwoord zijn verplicht" });
      }
      if (newPassword.length < 6) {
        return res.status(400).json({ message: "Nieuw wachtwoord moet minimaal 6 karakters zijn" });
      }
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const loginResult = await authService.login(req.user.email, currentPassword);
      if (!loginResult.success) {
        return res.status(400).json({ message: "Huidig wachtwoord is incorrect" });
      }
      const hashedPassword = await authService.hashPassword(newPassword);
      await storage.updateUser(req.user.id, { passwordHash: hashedPassword });
      res.json({ message: "Wachtwoord succesvol gewijzigd" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ message: "Er is een fout opgetreden bij het wijzigen van het wachtwoord" });
    }
  });
  app2.get("/api/dashboard/stats", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const stats = await storage.getDashboardStats(req.tenantId);
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });
  app2.get("/api/members", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const members2 = await storage.getMembersByTenant(req.tenantId);
      const membersWithDetails = await Promise.all(
        members2.map(async (member) => {
          const [financialSettings, permissions] = await Promise.all([
            storage.getMemberFinancialSettings(member.id),
            storage.getMemberPermissions(member.id)
          ]);
          return {
            ...member,
            financialSettings,
            permissions
          };
        })
      );
      res.json(membersWithDetails);
    } catch (error) {
      console.error("Members API error:", error);
      res.status(500).json({ message: "Failed to fetch members" });
    }
  });
  app2.get("/api/members/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const member = await storage.getMember(req.params.id);
      if (!member || member.tenantId !== req.tenantId) {
        return res.status(404).json({ message: "Member not found" });
      }
      const [financialSettings, permissions] = await Promise.all([
        storage.getMemberFinancialSettings(member.id),
        storage.getMemberPermissions(member.id)
      ]);
      res.json({
        ...member,
        financialSettings,
        permissions
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch member" });
    }
  });
  app2.post("/api/members/check-duplicates", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const memberData = req.body;
      const allMembers = await storage.getMembersByTenant(req.tenantId);
      const memberNumbers = allMembers.map((m) => m.memberNumber);
      console.log("\u{1F50D} TENANT:", req.tenantId);
      console.log("\u{1F50D} EXISTING NUMBERS:", memberNumbers);
      console.log("\u{1F50D} CHECKING FOR:", memberData.memberNumber);
      console.log("\u{1F50D} NORMALIZED CHECK:", memberData.memberNumber ? memberData.memberNumber.padStart(4, "0") : "NO NUMBER");
      const duplicateCheck = await memberService.checkForDuplicates(req.tenantId, memberData);
      console.log("\u{1F50D} RESULT:", duplicateCheck);
      res.json(duplicateCheck);
    } catch (error) {
      console.error("Error checking duplicates:", error);
      res.status(500).json({ message: "Failed to check for duplicates" });
    }
  });
  app2.post("/api/members", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const transformedData = {
        ...req.body,
        // Convert string date to Date object if needed
        birthDate: typeof req.body.birthDate === "string" ? new Date(req.body.birthDate) : req.body.birthDate
      };
      const memberData = createMemberSchema2.parse(transformedData);
      const result = await memberService.createMember(req.tenantId, memberData);
      if (!result.success) {
        return res.status(400).json({ message: result.message });
      }
      res.status(201).json(result.member);
    } catch (error) {
      console.error("Error creating member:", error);
      if (error instanceof z7.ZodError) {
        return res.status(400).json({
          message: "Invalid member data",
          errors: error.issues
        });
      }
      res.status(400).json({ message: "Invalid member data" });
    }
  });
  app2.put("/api/members/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      console.log("PUT member request body:", JSON.stringify(req.body, null, 2));
      const transformedData = {
        ...req.body,
        // Convert string date to Date object if needed
        birthDate: req.body.birthDate && typeof req.body.birthDate === "string" ? new Date(req.body.birthDate) : req.body.birthDate
      };
      if (!transformedData.birthDate || isNaN(transformedData.birthDate.getTime())) {
        delete transformedData.birthDate;
      }
      if (req.body.organization?.votingEligible !== void 0) {
        transformedData.votingRights = req.body.organization.votingEligible;
        console.log("PUT mapped voting rights:", transformedData.votingRights);
      }
      console.log("PUT transformed data:", JSON.stringify(transformedData, null, 2));
      const memberData = insertMemberSchema.partial().parse(transformedData);
      console.log("PUT parsed member data:", JSON.stringify(memberData, null, 2));
      const member = await storage.getMember(req.params.id);
      if (!member || member.tenantId !== req.tenantId) {
        return res.status(404).json({ message: "Member not found" });
      }
      const updatedMember = await storage.updateMember(req.params.id, memberData);
      console.log("PUT updated member successfully:", updatedMember.id);
      if (memberData.active === false) {
        try {
          await db.update(cardMeta).set({
            status: "VERLOPEN"
          }).where(eq8(cardMeta.memberId, req.params.id));
          console.log("PUT: Automatically set card status to VERLOPEN for deactivated member:", req.params.id);
        } catch (cardError) {
          console.error("PUT: Error updating card status for deactivated member:", cardError);
        }
      } else if (memberData.active === true && member.active === false) {
        try {
          await cardService.recalculateCardStatus(req.params.id, req.tenantId);
          console.log("PUT: Recalculated card status for reactivated member:", req.params.id);
        } catch (cardError) {
          console.error("PUT: Error recalculating card status for reactivated member:", cardError);
        }
      }
      res.json(updatedMember);
    } catch (error) {
      console.error("Error updating member - detailed:", error);
      if (error instanceof z7.ZodError) {
        console.error("Zod validation errors:", error.issues);
        return res.status(400).json({
          message: "Invalid member data",
          errors: error.issues
        });
      }
      res.status(500).json({ message: "Server error updating member" });
    }
  });
  app2.patch("/api/members/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      console.log("PATCH member request body:", JSON.stringify(req.body, null, 2));
      const transformedData = {
        ...req.body,
        // Convert string date to Date object if needed
        birthDate: req.body.birthDate && typeof req.body.birthDate === "string" ? new Date(req.body.birthDate) : req.body.birthDate
      };
      if (!transformedData.birthDate) {
        delete transformedData.birthDate;
      }
      if (req.body.organization?.votingEligible !== void 0) {
        transformedData.votingRights = req.body.organization.votingEligible;
        console.log("PATCH mapped voting rights:", transformedData.votingRights);
      }
      const memberData = insertMemberSchema.partial().parse(transformedData);
      console.log("PATCH parsed member data:", JSON.stringify(memberData, null, 2));
      const member = await storage.getMember(req.params.id);
      if (!member || member.tenantId !== req.tenantId) {
        return res.status(404).json({ message: "Member not found" });
      }
      const updatedMember = await storage.updateMember(req.params.id, memberData);
      console.log("Updated member successfully:", updatedMember.id);
      if (memberData.active === false) {
        try {
          await db.update(cardMeta).set({
            status: "VERLOPEN"
          }).where(eq8(cardMeta.memberId, req.params.id));
          console.log("PATCH: Automatically set card status to VERLOPEN for deactivated member:", req.params.id);
        } catch (cardError) {
          console.error("PATCH: Error updating card status for deactivated member:", cardError);
        }
      } else if (memberData.active === true && member.active === false) {
        try {
          await cardService.recalculateCardStatus(req.params.id, req.tenantId);
          console.log("PATCH: Recalculated card status for reactivated member:", req.params.id);
        } catch (cardError) {
          console.error("PATCH: Error recalculating card status for reactivated member:", cardError);
        }
      }
      res.json(updatedMember);
    } catch (error) {
      console.error("Error updating member - detailed:", error);
      if (error instanceof z7.ZodError) {
        console.error("Zod validation errors:", error.issues);
        return res.status(400).json({
          message: "Invalid member data",
          errors: error.issues
        });
      }
      res.status(500).json({ message: "Server error updating member" });
    }
  });
  app2.delete("/api/members/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const member = await storage.getMember(req.params.id);
      if (!member || member.tenantId !== req.tenantId) {
        return res.status(404).json({ message: "Member not found" });
      }
      await storage.deleteMember(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting member:", error);
      res.status(500).json({ message: "Failed to delete member" });
    }
  });
  app2.post("/api/members/export", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const { memberIds, fields } = req.body;
      if (!memberIds || !Array.isArray(memberIds) || memberIds.length === 0) {
        return res.status(400).json({ message: "Member IDs are required" });
      }
      if (!fields || !Array.isArray(fields) || fields.length === 0) {
        return res.status(400).json({ message: "Export fields are required" });
      }
      const members2 = await Promise.all(
        memberIds.map(async (memberId) => {
          const member = await storage.getMember(memberId);
          if (!member || member.tenantId !== req.tenantId) {
            return null;
          }
          const [financialSettings, permissions] = await Promise.all([
            storage.getMemberFinancialSettings(member.id),
            storage.getMemberPermissions(member.id)
          ]);
          return {
            ...member,
            financialSettings,
            permissions
          };
        })
      );
      const validMembers = members2.filter((member) => member !== null);
      const exportData = validMembers.map((member) => {
        const row = {};
        fields.forEach((field) => {
          switch (field) {
            case "memberNumber":
              row["Lidnummer"] = member.memberNumber;
              break;
            case "firstName":
              row["Voornaam"] = member.firstName;
              break;
            case "lastName":
              row["Achternaam"] = member.lastName;
              break;
            case "birthDate":
              row["Geboortedatum"] = member.birthDate ? new Date(member.birthDate).toLocaleDateString("nl-BE") : "";
              break;
            case "gender":
              row["Geslacht"] = member.gender === "M" ? "Man" : member.gender === "V" ? "Vrouw" : "";
              break;
            case "nationality":
              row["Nationaliteit"] = member.country || "";
              break;
            case "email":
              row["E-mail"] = member.email || "";
              break;
            case "phone":
              row["Telefoon"] = member.phone || "";
              break;
            case "address":
              row["Adres"] = member.street && member.number ? `${member.street} ${member.number}${member.bus ? `/${member.bus}` : ""}` : "";
              break;
            case "postalCode":
              row["Postcode"] = member.postalCode || "";
              break;
            case "city":
              row["Stad"] = member.city || "";
              break;
            case "country":
              row["Land"] = member.country || "";
              break;
            case "status":
              row["Status"] = member.active ? "Actief" : "Inactief";
              break;
            case "category":
              row["Categorie"] = member.category;
              break;
            case "joinDate":
              row["Inschrijfdatum"] = member.createdAt ? new Date(member.createdAt).toLocaleDateString("nl-BE") : "";
              break;
            case "votingRights":
              row["Stemrecht"] = member.votingRights ? "Ja" : "Nee";
              break;
            case "membershipFee":
              row["Lidmaatschapsbijdrage"] = "";
              break;
            case "paymentMethod":
              row["Betaalmethode"] = member.financialSettings?.paymentMethod || "";
              break;
            case "iban":
              row["IBAN"] = member.financialSettings?.iban || "";
              break;
            case "paymentStatus":
              row["Betaalstatus"] = "";
              break;
            case "emergencyContact":
              row["Noodcontact"] = "";
              break;
            case "emergencyPhone":
              row["Noodcontact telefoon"] = "";
              break;
            case "notes":
              row["Notities"] = "";
              break;
          }
        });
        return row;
      });
      const wb = XLSX.utils.book_new();
      const ws2 = XLSX.utils.json_to_sheet(exportData);
      const colWidths = Object.keys(exportData[0] || {}).map((key) => ({
        wch: Math.max(key.length, 15)
      }));
      ws2["!cols"] = colWidths;
      XLSX.utils.book_append_sheet(wb, ws2, "Leden");
      const excelBuffer = XLSX.write(wb, { type: "buffer", bookType: "xlsx" });
      const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
      res.setHeader("Content-Disposition", `attachment; filename="leden_export_${timestamp2}.xlsx"`);
      res.send(excelBuffer);
    } catch (error) {
      console.error("Error exporting members:", error);
      res.status(500).json({ message: "Failed to export members" });
    }
  });
  app2.get("/api/fees", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const fees = await storage.getMembershipFeesByTenant(req.tenantId);
      res.json(fees);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch membership fees" });
    }
  });
  app2.get("/api/fees/member/:memberId", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const fees = await storage.getMembershipFeesByMember(req.params.memberId);
      res.json(fees);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch member fees" });
    }
  });
  app2.post("/api/fees", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const feeData = insertMembershipFeeSchema.parse(req.body);
      const fee = await storage.createMembershipFee({
        ...feeData,
        tenantId: req.tenantId
      });
      res.status(201).json(fee);
    } catch (error) {
      res.status(400).json({ message: "Invalid fee data" });
    }
  });
  app2.put("/api/fees/:id/mark-paid", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const result = await feeService.markFeePaid(req.params.id, req.tenantId);
      if (!result.success) {
        return res.status(400).json({ message: result.message });
      }
      res.json(result.fee);
    } catch (error) {
      res.status(500).json({ message: "Failed to mark fee as paid" });
    }
  });
  app2.delete("/api/fees/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      await storage.deleteMembershipFee(req.params.id, req.tenantId);
      res.json({ message: "Lidgeld verwijderd" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete membership fee" });
    }
  });
  app2.get("/api/transactions", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const transactions2 = await storage.getTransactionsByTenant(req.tenantId);
      res.json(transactions2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch transactions" });
    }
  });
  app2.post("/api/transactions", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const transactionData = {
        ...req.body,
        tenantId: req.tenantId,
        date: new Date(req.body.date)
      };
      const transaction = await storage.createTransaction(transactionData);
      res.status(201).json(transaction);
    } catch (error) {
      console.error("Error creating transaction:", error);
      res.status(400).json({ message: "Invalid transaction data" });
    }
  });
  app2.put("/api/transactions/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const transactionData = {
        ...req.body,
        date: req.body.date ? new Date(req.body.date) : void 0
      };
      const transaction = await storage.updateTransaction(req.params.id, transactionData);
      res.json(transaction);
    } catch (error) {
      console.error("Error updating transaction:", error);
      res.status(400).json({ message: "Invalid transaction data" });
    }
  });
  app2.delete("/api/transactions/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      await storage.deleteTransaction(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting transaction:", error);
      res.status(500).json({ message: "Failed to delete transaction" });
    }
  });
  app2.get("/api/financial/reports", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const reports = await financialService.generateReports(req.tenantId);
      res.json(reports);
    } catch (error) {
      res.status(500).json({ message: "Failed to generate financial reports" });
    }
  });
  app2.get("/api/tenant/current", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const tenant = await storage.getTenant(req.tenantId);
      if (!tenant) {
        return res.status(404).json({ message: "Tenant not found" });
      }
      const mappedTenant = {
        id: tenant.id,
        name: tenant.name,
        slug: tenant.slug,
        street: tenant.street,
        number: tenant.number,
        postalCode: tenant.postalCode,
        city: tenant.city,
        country: tenant.country,
        email: tenant.email,
        phone: tenant.phone,
        website: tenant.website,
        companyNumber: tenant.companyNumber,
        companyType: tenant.companyType,
        logoUrl: tenant.logoUrl,
        primaryColor: tenant.primaryColor,
        // Include fee settings
        studentFee: tenant.studentFee,
        adultFee: tenant.adultFee,
        seniorFee: tenant.seniorFee,
        defaultPaymentTerm: tenant.defaultPaymentTerm,
        defaultPaymentMethod: tenant.defaultPaymentMethod,
        createdAt: tenant.createdAt
      };
      res.json(mappedTenant);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch tenant" });
    }
  });
  app2.put("/api/tenant/current", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const tenantData = req.body;
      const mappedData = {
        name: tenantData.name,
        slug: tenantData.slug,
        street: tenantData.street,
        number: tenantData.number,
        postalCode: tenantData.postalCode,
        city: tenantData.city,
        country: tenantData.country,
        email: tenantData.email,
        phone: tenantData.phone,
        website: tenantData.website,
        companyNumber: tenantData.companyNumber,
        companyType: tenantData.companyType,
        logoUrl: tenantData.logoUrl,
        primaryColor: tenantData.primaryColor
      };
      const updatedTenant = await storage.updateTenant(req.tenantId, mappedData);
      const mappedResponse = {
        id: updatedTenant.id,
        name: updatedTenant.name,
        slug: updatedTenant.slug,
        street: updatedTenant.street,
        number: updatedTenant.number,
        postalCode: updatedTenant.postalCode,
        city: updatedTenant.city,
        country: updatedTenant.country,
        email: updatedTenant.email,
        phone: updatedTenant.phone,
        website: updatedTenant.website,
        companyNumber: updatedTenant.companyNumber,
        companyType: updatedTenant.companyType,
        logoUrl: updatedTenant.logoUrl,
        primaryColor: updatedTenant.primaryColor,
        createdAt: updatedTenant.createdAt
      };
      res.json(mappedResponse);
    } catch (error) {
      res.status(500).json({ message: "Failed to update tenant" });
    }
  });
  app2.put("/api/settings/fees", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const { studentFee, adultFee, seniorFee, defaultPaymentTerm, defaultPaymentMethod } = req.body;
      const updatedTenant = await storage.updateTenant(req.tenantId, {
        studentFee: studentFee ? parseFloat(studentFee).toString() : void 0,
        adultFee: adultFee ? parseFloat(adultFee).toString() : void 0,
        seniorFee: seniorFee ? parseFloat(seniorFee).toString() : void 0,
        defaultPaymentTerm,
        defaultPaymentMethod
      });
      res.json({ success: true, message: "Fee settings updated", data: updatedTenant });
    } catch (error) {
      console.error("Error updating fee settings:", error);
      res.status(500).json({ message: "Failed to update fee settings" });
    }
  });
  app2.get("/api/users", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const users2 = await storage.getUsersByTenant(req.tenantId);
      res.json(users2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.post("/api/users", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      const user = await storage.createUser({
        ...userData,
        tenantId: req.tenantId
      });
      res.status(201).json(user);
    } catch (error) {
      res.status(400).json({ message: "Invalid user data" });
    }
  });
  app2.put("/api/users/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const userData = insertUserSchema.partial().parse(req.body);
      const user = await storage.updateUser(req.params.id, userData);
      res.json(user);
    } catch (error) {
      res.status(400).json({ message: "Invalid user data" });
    }
  });
  app2.delete("/api/users/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      await storage.deleteUser(req.params.id);
      res.json({ message: "User deleted successfully" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete user" });
    }
  });
  app2.post("/api/users/:id/reset-password", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const newPassword = Math.random().toString(36).slice(-8);
      const hashedPassword = await authService.hashPassword(newPassword);
      await storage.updateUser(req.params.id, { passwordHash: hashedPassword });
      res.json({
        message: "Password reset successfully",
        temporaryPassword: newPassword
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to reset password" });
    }
  });
  app2.get("/api/rules", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const rules2 = await storage.getRulesByTenant(req.tenantId);
      res.json(rules2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch rules" });
    }
  });
  app2.post("/api/rules", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const ruleData = req.body;
      const rule = await storage.createRule({
        ...ruleData,
        tenantId: req.tenantId
      });
      res.status(201).json(rule);
    } catch (error) {
      res.status(400).json({ message: "Invalid rule data" });
    }
  });
  app2.put("/api/rules/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const ruleData = req.body;
      const rule = await storage.updateRule(req.params.id, ruleData);
      res.json(rule);
    } catch (error) {
      res.status(400).json({ message: "Invalid rule data" });
    }
  });
  app2.delete("/api/rules/:id", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      await storage.deleteRule(req.params.id);
      res.json({ message: "Rule deleted successfully" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete rule" });
    }
  });
  app2.get("/api/public-screens", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const screens = await storage.getPublicScreensByTenant(req.tenantId);
      res.json(screens);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch public screens" });
    }
  });
  app2.get("/api/notifications", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const notifications2 = await storage.getNotificationsByTenant(req.tenantId);
      res.json(notifications2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });
  app2.get("/api/sepa-exports", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const exports = await storage.getSepaExportsByTenant(req.tenantId);
      res.json(exports);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch SEPA exports" });
    }
  });
  app2.post("/api/jobs/fees/generate", generateFeesHandler);
  app2.post("/api/members/create", authMiddleware, tenantMiddleware, createMemberHandler);
  app2.use("/api/public-screens", public_screens_default);
  app2.post("/api/card/invalidate", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const { memberId, tenantBrandingBump } = req.body;
      if (memberId) {
        const cardData = await cardService.getCardData(memberId);
        if (cardData && cardData.member.tenantId === req.tenantId) {
          await cardService.invalidateCard(cardData.cardMeta.id);
        }
      }
      if (tenantBrandingBump) {
      }
      res.json({ success: true, message: "Card invalidated" });
    } catch (error) {
      console.error("Error invalidating card:", error);
      res.status(500).json({ message: "Failed to invalidate card" });
    }
  });
  app2.get("/api/tenant/current", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const tenant = await storage.getTenant(req.tenantId);
      if (!tenant) {
        return res.status(404).json({ message: "Tenant not found" });
      }
      res.json(tenant);
    } catch (error) {
      console.error("Error fetching tenant:", error);
      res.status(500).json({ message: "Failed to fetch tenant" });
    }
  });
  app2.get("/api/cards", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const cards = await storage.getAllCardsWithMembers(req.tenantId);
      res.json(cards);
    } catch (error) {
      console.error("Error fetching cards:", error);
      res.status(500).json({ message: "Failed to fetch cards" });
    }
  });
  app2.get("/api/cards/stats", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const stats = await storage.getCardStats(req.tenantId);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching card stats:", error);
      res.status(500).json({ message: "Failed to fetch card stats" });
    }
  });
  app2.post("/api/cards/:memberId/create", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const { memberId } = req.params;
      const member = await storage.getMember(memberId);
      if (!member || member.tenantId !== req.tenantId) {
        return res.status(404).json({ message: "Member not found" });
      }
      const existingCard = await storage.getCardMetaByMember(memberId);
      if (existingCard) {
        return res.status(409).json({ message: "Card already exists for this member" });
      }
      const cardData = await cardService.getOrCreateCardMeta(memberId);
      if (cardData) {
        res.json({ success: true, message: "Card created", card: cardData });
      } else {
        res.status(500).json({ message: "Failed to create card" });
      }
    } catch (error) {
      console.error("Error creating card:", error);
      res.status(500).json({ message: "Failed to create card" });
    }
  });
  app2.post("/api/cards/:memberId/regenerate", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const { memberId } = req.params;
      const member = await storage.getMember(memberId);
      if (!member || member.tenantId !== req.tenantId) {
        return res.status(404).json({ message: "Member not found" });
      }
      const cardData = await cardService.getOrCreateCardMeta(memberId);
      if (cardData) {
        await cardService.invalidateCard(memberId);
        res.json({ success: true, message: "Card regenerated" });
      } else {
        res.status(500).json({ message: "Failed to regenerate card" });
      }
    } catch (error) {
      console.error("Error regenerating card:", error);
      res.status(500).json({ message: "Failed to regenerate card" });
    }
  });
  app2.post("/api/cards/:memberId/deactivate", authMiddleware, tenantMiddleware, async (req, res) => {
    try {
      const { memberId } = req.params;
      const member = await storage.getMember(memberId);
      if (!member || member.tenantId !== req.tenantId) {
        return res.status(404).json({ message: "Member not found" });
      }
      const cardMeta2 = await storage.getCardMetaByMember(memberId);
      if (cardMeta2) {
        await storage.updateCardMeta(cardMeta2.id, { status: "VERLOPEN" });
        res.json({ success: true, message: "Card deactivated" });
      } else {
        res.status(404).json({ message: "Card not found" });
      }
    } catch (error) {
      console.error("Error deactivating card:", error);
      res.status(500).json({ message: "Failed to deactivate card" });
    }
  });
  const verificationRateLimit = /* @__PURE__ */ new Map();
  const RATE_LIMIT_WINDOW_MS = 60 * 1e3;
  const RATE_LIMIT_MAX_REQUESTS = 30;
  function checkRateLimit(ip) {
    const now = Date.now();
    const userLimit = verificationRateLimit.get(ip);
    if (!userLimit || now > userLimit.resetTime) {
      verificationRateLimit.set(ip, { count: 1, resetTime: now + RATE_LIMIT_WINDOW_MS });
      return true;
    }
    if (userLimit.count >= RATE_LIMIT_MAX_REQUESTS) {
      return false;
    }
    userLimit.count++;
    return true;
  }
  function deriveCardStatus(cardMeta2, member, fees) {
    if (!member.active) {
      return "VERLOPEN";
    }
    if (cardMeta2.validUntil && new Date(cardMeta2.validUntil) < /* @__PURE__ */ new Date()) {
      return "VERLOPEN";
    }
    if (cardMeta2.status === "VERLOPEN") {
      return "VERLOPEN";
    }
    if (cardMeta2.status === "MOMENTOPNAME") {
      return "NIET_ACTUEEL";
    }
    return cardMeta2.status || "ACTUEEL";
  }
  app2.get("/api/card/:memberId", async (req, res) => {
    try {
      const { memberId } = req.params;
      const cardData = await cardService.getCardData(memberId);
      if (!cardData) {
        return res.status(404).json({ message: "Card not found" });
      }
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      const memberFees = await storage.getMembershipFeesByMember(memberId);
      const currentYearFees = memberFees.filter((fee) => {
        const feeYear = new Date(fee.periodStart).getFullYear();
        return feeYear === currentYear;
      });
      const currentYearPaid = currentYearFees.some((fee) => fee.status === "PAID");
      const badges = [];
      if (currentYearPaid) {
        badges.push(`Betaald ${currentYear}`);
      }
      if (cardData.member.votingRights) {
        badges.push("Stemgerechtigd");
      }
      const response = {
        memberId: cardData.member.id,
        firstName: cardData.member.firstName,
        lastName: cardData.member.lastName,
        memberNumber: cardData.member.memberNumber,
        category: cardData.member.category,
        status: cardData.cardMeta.status,
        validUntil: cardData.cardMeta.validUntil,
        votingRights: cardData.member.votingRights || false,
        badges,
        qrToken: cardData.cardMeta.qrToken,
        tenant: {
          name: cardData.tenant.name,
          logoUrl: cardData.tenant.logoUrl,
          primaryColor: cardData.tenant.primaryColor || "#bb2e2e"
        },
        etag: cardData.cardMeta.etag
      };
      res.set("ETag", cardData.cardMeta.etag);
      res.json(response);
    } catch (error) {
      console.error("Error fetching card data:", error);
      res.status(500).json({ message: "Failed to fetch card data" });
    }
  });
  app2.get("/api/card/verify/:qrToken", quickAuthMiddleware, async (req, res) => {
    try {
      const { qrToken } = req.params;
      const clientIp = req.ip || req.connection.remoteAddress || "unknown";
      if (!checkRateLimit(clientIp)) {
        return res.status(429).json({
          error: "Te veel verzoeken. Probeer later opnieuw."
        });
      }
      if (!qrToken || typeof qrToken !== "string" || qrToken.length < 10) {
        return res.status(404).json({
          error: "Onbekende of ingetrokken code"
        });
      }
      const cardMeta2 = await storage.getCardMetaByQrToken(qrToken);
      if (!cardMeta2) {
        return res.status(404).json({
          error: "Onbekende of ingetrokken code"
        });
      }
      const member = await storage.getMember(cardMeta2.memberId);
      const tenant = await storage.getTenant(cardMeta2.tenantId);
      if (!member || !tenant) {
        return res.status(404).json({
          error: "Onbekende of ingetrokken code"
        });
      }
      const memberFees = await storage.getMembershipFeesByMember(member.id);
      const status = deriveCardStatus(cardMeta2, member, memberFees);
      const validUntil = cardMeta2.validUntil ? new Date(cardMeta2.validUntil).toLocaleDateString("nl-BE", {
        day: "2-digit",
        month: "2-digit",
        year: "numeric",
        timeZone: "Europe/Brussels"
      }) : null;
      const eligibleToVote = member.votingRights || false;
      const categoryLabels = {
        "STUDENT": "Student",
        "STANDAARD": "Standaard",
        "SENIOR": "Senior"
      };
      const category = categoryLabels[member.category] || member.category;
      let age = null;
      if (member.birthDate) {
        const birthDate = new Date(member.birthDate);
        const today = /* @__PURE__ */ new Date();
        age = today.getFullYear() - birthDate.getFullYear();
        const monthDiff = today.getMonth() - birthDate.getMonth();
        if (monthDiff < 0 || monthDiff === 0 && today.getDate() < birthDate.getDate()) {
          age--;
        }
      }
      const cutoffDate = /* @__PURE__ */ new Date();
      cutoffDate.setFullYear(cutoffDate.getFullYear() - 2);
      const recentFees = memberFees.filter((fee) => new Date(fee.periodStart) >= cutoffDate).sort((a, b) => new Date(b.periodStart).getTime() - new Date(a.periodStart).getTime()).slice(0, 6).map((fee) => ({
        id: fee.id,
        period: `${new Date(fee.periodStart).getFullYear()}`,
        amount: fee.amount,
        status: fee.status,
        periodEnd: new Date(fee.periodEnd).toLocaleDateString("nl-BE", {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
          timeZone: "Europe/Brussels"
        }),
        paidAt: fee.paidAt ? new Date(fee.paidAt).toLocaleDateString("nl-BE", {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
          timeZone: "Europe/Brussels"
        }) : null
      }));
      let boardInfo = null;
      try {
        const boardMember = await boardService.getBoardMemberByMemberId(null, member.id);
        if (boardMember && boardMember.boardMember?.status === "ACTIEF") {
          boardInfo = {
            isActiveBoardMember: true,
            role: boardMember.boardMember.role,
            customRole: boardMember.boardMember.customRole
          };
        }
      } catch (error) {
        console.error("Error fetching board member status:", error);
      }
      const outstandingFees = recentFees.filter((fee) => fee.status === "PENDING" || fee.status === "OVERDUE" || fee.status === "OPEN");
      const paidFees = recentFees.filter((fee) => fee.status === "PAID");
      let paymentStatusSummary = "Alles is betaald";
      let paymentDetails = [];
      if (outstandingFees.length > 0) {
        const overdueFees = outstandingFees.filter((fee) => fee.status === "OVERDUE");
        const pendingFees = outstandingFees.filter((fee) => fee.status === "PENDING" || fee.status === "OPEN");
        if (overdueFees.length > 0) {
          const overdueList = overdueFees.map((fee) => {
            const periodStart = new Date(fee.periodEnd).toLocaleDateString("nl-BE", { month: "short", year: "numeric" });
            return `${periodStart} (\u20AC${fee.amount})`;
          }).join(", ");
          paymentDetails.push(`Vervallen: ${overdueList}`);
        }
        if (pendingFees.length > 0) {
          const pendingList = pendingFees.map((fee) => {
            const periodStart = new Date(fee.periodEnd).toLocaleDateString("nl-BE", { month: "short", year: "numeric" });
            return `${periodStart} (\u20AC${fee.amount})`;
          }).join(", ");
          paymentDetails.push(`Openstaand: ${pendingList}`);
        }
        const overdueCount = overdueFees.length;
        const pendingCount = pendingFees.length;
        if (overdueCount > 0 && pendingCount > 0) {
          paymentStatusSummary = `${overdueCount} vervallen en ${pendingCount} openstaande betalingen`;
        } else if (overdueCount > 0) {
          paymentStatusSummary = `${overdueCount} vervallen ${overdueCount === 1 ? "betaling" : "betalingen"}`;
        } else {
          paymentStatusSummary = `${pendingCount} openstaande ${pendingCount === 1 ? "betaling" : "betalingen"}`;
        }
      }
      const response = {
        status,
        validUntil,
        eligibleToVote,
        member: {
          name: `${member.firstName} ${member.lastName}`,
          memberNumber: member.memberNumber,
          category,
          age
        },
        tenant: {
          name: tenant.name,
          logoUrl: tenant.logoUrl
        },
        fees: recentFees,
        paymentStatus: {
          summary: paymentStatusSummary,
          details: paymentDetails,
          totalOutstanding: outstandingFees.length,
          totalPaid: paidFees.length,
          hasOutstanding: outstandingFees.length > 0
        },
        boardInfo,
        refreshedAt: (/* @__PURE__ */ new Date()).toISOString(),
        etag: cardMeta2.etag
      };
      res.set({
        "Cache-Control": "no-store",
        "Content-Type": "application/json; charset=utf-8"
      });
      if (cardMeta2.etag) {
        res.set("ETag", cardMeta2.etag);
      }
      res.json(response);
    } catch (error) {
      console.error("Error in card verification:", error);
      res.status(500).json({
        error: "Er ging iets mis. Probeer opnieuw."
      });
    }
  });
  app2.get("/api/public/card/:memberId", async (req, res) => {
    try {
      const { memberId } = req.params;
      const member = await storage.getMember(memberId);
      if (!member || !member.active) {
        return res.status(404).json({ message: "Card not found" });
      }
      const tenant = await storage.getTenant(member.tenantId);
      if (!tenant) {
        return res.status(404).json({ message: "Organization not found" });
      }
      let cardMeta2 = await storage.getCardMetaByMember(memberId);
      if (!cardMeta2) {
        cardMeta2 = await storage.createCardMeta({
          memberId,
          tenantId: member.tenantId,
          qrToken: randomBytes3(32).toString("hex"),
          validUntil: new Date((/* @__PURE__ */ new Date()).getFullYear(), 11, 31),
          // End of current year
          etag: makeCardETag(
            {
              id: member.id,
              firstName: member.firstName,
              lastName: member.lastName,
              memberNumber: member.memberNumber,
              category: member.category,
              votingRights: member.votingRights || false
            },
            {
              name: tenant.name,
              logoUrl: tenant.logoUrl,
              primaryColor: tenant.primaryColor || "#bb2e2e"
            },
            "ACTUEEL",
            new Date((/* @__PURE__ */ new Date()).getFullYear(), 11, 31),
            []
          )
        });
      }
      const memberFees = await storage.getMembershipFeesByMember(memberId);
      const status = await computeCardStatus(memberId);
      const response = {
        memberId: member.id,
        firstName: member.firstName,
        lastName: member.lastName,
        memberNumber: member.memberNumber,
        category: member.category,
        votingRights: member.votingRights || false,
        status,
        validUntil: cardMeta2.validUntil,
        qrToken: cardMeta2.qrToken,
        tenant: {
          id: tenant.id,
          name: tenant.name,
          logoUrl: tenant.logoUrl
        }
      };
      res.set("Cache-Control", "public, max-age=10");
      res.json(response);
    } catch (error) {
      console.error("Error fetching public card data:", error);
      res.status(500).json({ message: "Failed to fetch card data" });
    }
  });
  app2.post("/api/members/:id/card/refresh-validuntil", authMiddleware, async (req, res) => {
    try {
      const memberId = req.params.id;
      const member = await storage.getMember(memberId);
      if (!member || !req.user || member.tenantId !== req.user.tenantId) {
        return res.status(404).json({ error: "Lid niet gevonden" });
      }
      const { updateMemberValidUntil: updateMemberValidUntil2 } = await Promise.resolve().then(() => (init_simple_validuntil(), simple_validuntil_exports));
      const { computeCardStatus: computeCardStatus2 } = await Promise.resolve().then(() => (init_status(), status_exports));
      const newValidUntil = await updateMemberValidUntil2(memberId);
      const newStatus = await computeCardStatus2(memberId);
      res.json({
        memberId,
        validUntil: newValidUntil?.toISOString() || null,
        status: newStatus,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Error refreshing card validUntil:", error);
      res.status(500).json({ error: "Fout bij het vernieuwen van geldigheid" });
    }
  });
  app2.get("/api/members/:id/card/status-details", authMiddleware, async (req, res) => {
    try {
      const memberId = req.params.id;
      const member = await storage.getMember(memberId);
      if (!member || !req.user || member.tenantId !== req.user.tenantId) {
        return res.status(404).json({ error: "Lid niet gevonden" });
      }
      const { getCardStatusDetails: getCardStatusDetails2 } = await Promise.resolve().then(() => (init_status(), status_exports));
      const details = await getCardStatusDetails2(memberId);
      res.json(details);
    } catch (error) {
      console.error("Error getting card status details:", error);
      res.status(500).json({ error: "Fout bij het ophalen van kaart status" });
    }
  });
  app2.post("/api/admin/rollover", authMiddleware, async (req, res) => {
    try {
      if (req.user.role !== "SUPERADMIN") {
        return res.status(403).json({ error: "Onvoldoende rechten voor deze actie" });
      }
      const { rolloverDaily: rolloverDaily2 } = await Promise.resolve().then(() => (init_rollover(), rollover_exports));
      const tenantId = req.body.tenantId || req.user.tenantId;
      const summary = await rolloverDaily2(tenantId);
      res.json({
        success: true,
        summary
      });
    } catch (error) {
      console.error("Error running rollover:", error);
      res.status(500).json({ error: "Fout bij het uitvoeren van rollover" });
    }
  });
  app2.post("/api/finance/import", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const { StatementImportService: StatementImportService2 } = await Promise.resolve().then(() => (init_import(), import_exports));
      const importService = new StatementImportService2();
      const { file, options } = req.body;
      const validation = importService.validateFile(file);
      if (!validation.valid) {
        return res.status(400).json({
          error: "Bestand validatie mislukt",
          details: validation.errors
        });
      }
      const result = await importService.importStatement(
        file,
        options,
        req.user.tenantId,
        req.user.id
      );
      res.json({
        success: true,
        statement: result.statement,
        transactionCount: result.transactions.length
      });
    } catch (error) {
      console.error("Import error:", error);
      res.status(500).json({
        error: "Fout bij importeren",
        message: error instanceof Error ? error.message : "Onbekende fout"
      });
    }
  });
  app2.post("/api/finance/import/preview", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const { StatementImportService: StatementImportService2 } = await Promise.resolve().then(() => (init_import(), import_exports));
      const importService = new StatementImportService2();
      const { file, options } = req.body;
      const preview = await importService.previewTransactions(file, options);
      res.json(preview);
    } catch (error) {
      console.error("Preview error:", error);
      res.status(500).json({
        error: "Fout bij preview",
        message: error instanceof Error ? error.message : "Onbekende fout"
      });
    }
  });
  app2.get("/api/finance/statements", authMiddleware, async (req, res) => {
    try {
      res.json([]);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen statements" });
    }
  });
  app2.get("/api/finance/bank-transactions", authMiddleware, async (req, res) => {
    try {
      const { status, from, to, side, category, vendor, q } = req.query;
      res.json([]);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen transacties" });
    }
  });
  app2.post("/api/finance/bank-transactions/:id/confirm", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const transactionId = req.params.id;
      const { matchedFeeId, matchedMemberId, categoryId, vendorId } = req.body;
      console.log(`Confirming match for transaction ${transactionId}`);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Fout bij bevestigen match" });
    }
  });
  app2.post("/api/finance/bank-transactions/:id/split", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const transactionId = req.params.id;
      const { splits } = req.body;
      console.log(`Splitting transaction ${transactionId}`);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Fout bij splitsen transactie" });
    }
  });
  app2.post("/api/finance/bank-transactions/:id/reject", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const transactionId = req.params.id;
      const { note } = req.body;
      console.log(`Rejecting transaction ${transactionId}`);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Fout bij afkeuren transactie" });
    }
  });
  app2.post("/api/finance/book", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const { statementId, transactionIds } = req.body;
      console.log(`Booking transactions`, { statementId, transactionIds });
      res.json({ success: true, bookedCount: transactionIds?.length || 0 });
    } catch (error) {
      res.status(500).json({ error: "Fout bij boeken transacties" });
    }
  });
  app2.get("/api/finance/categories", authMiddleware, async (req, res) => {
    try {
      res.json([]);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen categorie\xEBn" });
    }
  });
  app2.post("/api/finance/categories", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const { name, code, color } = req.body;
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Fout bij aanmaken categorie" });
    }
  });
  app2.get("/api/finance/vendors", authMiddleware, async (req, res) => {
    try {
      res.json([]);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen leveranciers" });
    }
  });
  app2.post("/api/finance/vendors", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const { name, iban, defaultCategoryId } = req.body;
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Fout bij aanmaken leverancier" });
    }
  });
  app2.get("/api/finance/rules", authMiddleware, async (req, res) => {
    try {
      res.json([]);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen regels" });
    }
  });
  app2.post("/api/finance/rules", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Onvoldoende rechten" });
      }
      const { name, priority, criteria, action } = req.body;
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Fout bij aanmaken regel" });
    }
  });
  app2.get("/api/reports/cashflow", authMiddleware, async (req, res) => {
    try {
      const { from, to, types, categories, methods, statuses } = req.query;
      const mockData = [
        { date: "2024-01-01", income: 12500, expense: 8300, net: 4200 },
        { date: "2024-01-02", income: 15600, expense: 9100, net: 6500 },
        { date: "2024-01-03", income: 13400, expense: 7800, net: 5600 }
      ];
      res.json(mockData);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen cashflow data" });
    }
  });
  app2.get("/api/reports/categories", authMiddleware, async (req, res) => {
    try {
      const { kind = "expense", from, to } = req.query;
      const mockData = [
        { category: "Lidgelden", amount: 25e3, count: 120 },
        { category: "Nutsvoorzieningen", amount: 4500, count: 12 },
        { category: "Onderhoud", amount: 3200, count: 8 },
        { category: "Verzekeringen", amount: 2800, count: 4 }
      ];
      res.json(mockData);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen categorie data" });
    }
  });
  app2.get("/api/reports/stacked-by-category", authMiddleware, async (req, res) => {
    try {
      const mockData = [
        { month: "2024-01", "Lidgelden": 8500, "Nutsvoorzieningen": 1200, "Onderhoud": 800 },
        { month: "2024-02", "Lidgelden": 9200, "Nutsvoorzieningen": 1100, "Onderhoud": 600 },
        { month: "2024-03", "Lidgelden": 7800, "Nutsvoorzieningen": 1300, "Onderhoud": 1200 }
      ];
      res.json(mockData);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen gestapelde data" });
    }
  });
  app2.get("/api/reports/fee-status-trend", authMiddleware, async (req, res) => {
    try {
      const mockData = [
        { month: "2024-01", betaald: 85, openstaand: 25, vervallen: 5 },
        { month: "2024-02", betaald: 92, openstaand: 18, vervallen: 8 },
        { month: "2024-03", betaald: 88, openstaand: 22, vervallen: 6 }
      ];
      res.json(mockData);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen fee status trend" });
    }
  });
  app2.get("/api/reports/top-members", authMiddleware, async (req, res) => {
    try {
      const mockData = [
        { memberId: "1", name: "Jan Janssen", total: 2500, count: 12, spark: [200, 220, 180, 250, 300] },
        { memberId: "2", name: "Marie Peeters", total: 2200, count: 11, spark: [180, 200, 210, 190, 220] },
        { memberId: "3", name: "Ahmed Hassan", total: 1950, count: 10, spark: [195, 180, 200, 175, 210] }
      ];
      res.json(mockData);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen top leden data" });
    }
  });
  app2.get("/api/reports/methods", authMiddleware, async (req, res) => {
    try {
      const mockData = [
        { method: "SEPA", amount: 18500, count: 85 },
        { method: "OVERSCHRIJVING", amount: 6200, count: 25 },
        { method: "BANCONTACT", amount: 1800, count: 12 },
        { method: "CASH", amount: 950, count: 8 },
        { method: "OVERIG", amount: 450, count: 3 }
      ];
      res.json(mockData);
    } catch (error) {
      res.status(500).json({ error: "Fout bij ophalen betaalmethode data" });
    }
  });
  app2.get("/api/members/:id/voting-rights", authMiddleware, async (req, res) => {
    try {
      const memberId = req.params.id;
      const tenantId = req.user.tenantId;
      const member = await storage.getMember(memberId);
      if (!member || member.tenantId !== tenantId) {
        return res.status(404).json({ error: "Lid niet gevonden" });
      }
      const status = await ruleService.getVotingRightsStatus(memberId, tenantId);
      res.json(status);
    } catch (error) {
      console.error("Error getting voting rights:", error);
      res.status(500).json({ error: "Fout bij ophalen stemrecht status" });
    }
  });
  app2.post("/api/members/:id/voting-rights/override", authMiddleware, async (req, res) => {
    try {
      const memberId = req.params.id;
      const tenantId = req.user.tenantId;
      const { overrideValue, reason } = req.body;
      const member = await storage.getMember(memberId);
      if (!member || member.tenantId !== tenantId) {
        return res.status(404).json({ error: "Lid niet gevonden" });
      }
      if (typeof overrideValue !== "boolean" || !reason || typeof reason !== "string") {
        return res.status(400).json({ error: "Ongeldige parameters" });
      }
      const override = await ruleService.createRuleOverride(
        memberId,
        tenantId,
        "STEMRECHT",
        overrideValue,
        reason,
        req.user.id
      );
      const updatedStatus = await ruleService.getVotingRightsStatus(memberId, tenantId);
      res.json({
        override,
        status: updatedStatus
      });
    } catch (error) {
      console.error("Error creating voting rights override:", error);
      res.status(500).json({ error: "Fout bij aanmaken stemrecht override" });
    }
  });
  app2.get("/api/public/board-status/:memberId", async (req, res) => {
    try {
      const memberId = req.params.memberId;
      if (!memberId) {
        return res.status(400).json({ error: "Member ID vereist" });
      }
      const boardMember = await boardService.getBoardMemberByMemberId(null, memberId);
      if (!boardMember) {
        return res.json({ isActiveBoardMember: false });
      }
      res.json({
        isActiveBoardMember: boardMember.boardMember?.status === "ACTIEF",
        role: boardMember.boardMember?.role
      });
    } catch (error) {
      console.error("Error fetching public board member status:", error);
      res.status(500).json({ error: "Fout bij ophalen bestuursstatus" });
    }
  });
  app2.get("/api/board/members", authMiddleware, async (req, res) => {
    try {
      const tenantId = req.user.tenantId;
      if (req.query.memberId) {
        const boardMember = await boardService.getBoardMemberByMemberId(tenantId, req.query.memberId);
        return res.json(boardMember ? [boardMember] : []);
      }
      const filters = {
        status: req.query.status,
        role: req.query.role,
        q: req.query.q
      };
      const boardMembers2 = await boardService.listBoardMembers(tenantId, filters);
      res.json(boardMembers2);
    } catch (error) {
      console.error("Error fetching board members:", error);
      res.status(500).json({ error: "Fout bij ophalen bestuursleden" });
    }
  });
  app2.get("/api/board/members/:id", authMiddleware, async (req, res) => {
    try {
      const tenantId = req.user.tenantId;
      const boardMember = await boardService.getBoardMember(tenantId, req.params.id);
      if (!boardMember) {
        return res.status(404).json({ error: "Bestuurslid niet gevonden" });
      }
      res.json(boardMember);
    } catch (error) {
      console.error("Error fetching board member:", error);
      res.status(500).json({ error: "Fout bij ophalen bestuurslid" });
    }
  });
  app2.post("/api/board/members", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const tenantId = req.user.tenantId;
      const boardMemberDataSchema = insertBoardMemberSchema.omit({ tenantId: true });
      const validatedData = boardMemberDataSchema.parse(req.body);
      const dataWithTenant = {
        ...validatedData,
        tenantId
      };
      const boardMember = await boardService.createBoardMember(tenantId, dataWithTenant);
      res.json(boardMember);
    } catch (error) {
      console.error("Error creating board member:", error);
      if (error instanceof z7.ZodError) {
        return res.status(400).json({ error: "Ongeldige gegevens", details: error.errors });
      }
      res.status(500).json({ error: "Fout bij aanmaken bestuurslid" });
    }
  });
  app2.put("/api/board/members/:id", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const tenantId = req.user.tenantId;
      const validatedData = insertBoardMemberSchema.partial().parse(req.body);
      const boardMember = await boardService.updateBoardMember(tenantId, req.params.id, validatedData);
      if (!boardMember) {
        return res.status(404).json({ error: "Bestuurslid niet gevonden" });
      }
      res.json(boardMember);
    } catch (error) {
      console.error("Error updating board member:", error);
      if (error instanceof z7.ZodError) {
        return res.status(400).json({ error: "Ongeldige gegevens", details: error.errors });
      }
      res.status(500).json({ error: "Fout bij bijwerken bestuurslid" });
    }
  });
  app2.post("/api/board/members/:id/end-term", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const tenantId = req.user.tenantId;
      const { endDate, note } = req.body;
      const result = await boardService.endActiveTerm(
        tenantId,
        req.params.id,
        new Date(endDate),
        note
      );
      res.json({ success: result });
    } catch (error) {
      console.error("Error ending board term:", error);
      res.status(500).json({ error: "Fout bij be\xEBindigen mandaat" });
    }
  });
  app2.post("/api/board/reorder", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const tenantId = req.user.tenantId;
      const orderData = req.body;
      const result = await boardService.reorderBoard(tenantId, orderData);
      res.json({ success: result });
    } catch (error) {
      console.error("Error reordering board:", error);
      res.status(500).json({ error: "Fout bij herordenen bestuur" });
    }
  });
  app2.get("/api/board/members/by-member/:memberId", authMiddleware, async (req, res) => {
    try {
      const tenantId = req.user.tenantId;
      const memberId = req.params.memberId;
      const boardMember = await boardService.getBoardMemberByMemberId(tenantId, memberId);
      res.json(boardMember);
    } catch (error) {
      console.error("Error fetching board member by member ID:", error);
      res.status(500).json({ error: "Fout bij ophalen bestuurslid" });
    }
  });
  const { EmailService: EmailService2 } = await Promise.resolve().then(() => (init_email(), email_exports));
  const emailService = new EmailService2();
  app2.get("/api/messages/templates", authMiddleware, async (req, res) => {
    try {
      const templates = await emailService.listTemplates(req.user.tenantId);
      res.set({
        "Cache-Control": "no-store, no-cache, must-revalidate",
        "Pragma": "no-cache",
        "Expires": "0"
      });
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ error: "Fout bij ophalen templates" });
    }
  });
  app2.post("/api/messages/templates", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const template = await emailService.createTemplate(req.user.tenantId, req.body);
      res.json(template);
    } catch (error) {
      console.error("Error creating template:", error);
      res.status(500).json({ error: "Fout bij aanmaken template" });
    }
  });
  app2.put("/api/messages/templates/:id", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const template = await emailService.updateTemplate(req.user.tenantId, req.params.id, req.body);
      res.json(template);
    } catch (error) {
      console.error("Error updating template:", error);
      res.status(500).json({ error: "Fout bij bijwerken template" });
    }
  });
  app2.delete("/api/messages/templates/:id", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      await emailService.deleteTemplate(req.user.tenantId, req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting template:", error);
      res.status(500).json({ error: "Fout bij verwijderen template" });
    }
  });
  app2.post("/api/messages/templates/:id/test", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const { toEmail, sampleContext } = req.body;
      await emailService.sendTestEmail(req.user.tenantId, req.params.id, toEmail, sampleContext);
      res.json({ success: true });
    } catch (error) {
      console.error("Error sending test email:", error);
      res.status(500).json({ error: "Fout bij verzenden testmail" });
    }
  });
  app2.get("/api/messages/segments", authMiddleware, async (req, res) => {
    try {
      const segments = await emailService.listSegments(req.user.tenantId);
      res.json(segments);
    } catch (error) {
      console.error("Error fetching segments:", error);
      res.status(500).json({ error: "Fout bij ophalen segmenten" });
    }
  });
  app2.post("/api/messages/segments", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const segment = await emailService.createSegment(req.user.tenantId, req.body);
      res.json(segment);
    } catch (error) {
      console.error("Error creating segment:", error);
      res.status(500).json({ error: "Fout bij aanmaken segment" });
    }
  });
  app2.delete("/api/messages/segments/:id", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      await emailService.deleteSegment(req.user.tenantId, req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting segment:", error);
      res.status(500).json({ error: "Fout bij verwijderen segment" });
    }
  });
  app2.post("/api/messages/segments/:id/preview", authMiddleware, async (req, res) => {
    try {
      const segment = await db.select().from(emailSegments).where(and(
        eq8(emailSegments.tenantId, req.user.tenantId),
        eq8(emailSegments.id, req.params.id)
      )).limit(1);
      if (!segment[0]) {
        return res.status(404).json({ error: "Segment niet gevonden" });
      }
      const preview = await emailService.previewSegment(req.user.tenantId, segment[0].rules);
      res.json(preview);
    } catch (error) {
      console.error("Error previewing segment:", error);
      res.status(500).json({ error: "Fout bij preview segment" });
    }
  });
  app2.get("/api/messages/campaigns", authMiddleware, async (req, res) => {
    try {
      const campaigns = await emailService.listCampaigns(req.user.tenantId);
      res.json(campaigns);
    } catch (error) {
      console.error("Error fetching campaigns:", error);
      res.status(500).json({ error: "Fout bij ophalen campagnes" });
    }
  });
  app2.post("/api/messages/campaigns", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const campaign = await emailService.createCampaign(req.user.tenantId, {
        ...req.body,
        createdById: req.user.id
      });
      res.json(campaign);
    } catch (error) {
      console.error("Error creating campaign:", error);
      res.status(500).json({ error: "Fout bij aanmaken campagne" });
    }
  });
  app2.post("/api/messages/campaigns/:id/queue", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const result = await emailService.queueCampaign(req.user.tenantId, req.params.id);
      res.json(result);
    } catch (error) {
      console.error("Error queuing campaign:", error);
      res.status(500).json({ error: "Fout bij in queue zetten campagne" });
    }
  });
  app2.post("/api/messages/worker/tick", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const result = await emailService.processQueuedMessages(limit);
      res.json(result);
    } catch (error) {
      console.error("Error processing queued messages:", error);
      res.status(500).json({ error: "Fout bij verwerken berichten" });
    }
  });
  app2.get("/api/messages/track/open/:messageId/:token.png", async (req, res) => {
    try {
      await emailService.trackOpen(req.params.messageId, req.params.token);
      const img = Buffer.from("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=", "base64");
      res.writeHead(200, {
        "Content-Type": "image/png",
        "Content-Length": img.length,
        "Cache-Control": "no-cache"
      });
      res.end(img);
    } catch (error) {
      console.error("Error tracking open:", error);
      res.status(404).end();
    }
  });
  app2.get("/api/messages/track/click/:messageId/:token", async (req, res) => {
    try {
      const originalUrl = decodeURIComponent(req.query.u);
      const redirectUrl = await emailService.trackClick(req.params.messageId, req.params.token, originalUrl);
      if (redirectUrl) {
        res.redirect(302, redirectUrl);
      } else {
        res.status(404).send("Link not found");
      }
    } catch (error) {
      console.error("Error tracking click:", error);
      res.status(404).send("Link not found");
    }
  });
  app2.post("/api/messages/send", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const { templateCode, memberId, email, context } = req.body;
      const message = await emailService.sendTransactional(req.user.tenantId, templateCode, {
        memberId,
        email,
        context
      });
      res.json(message);
    } catch (error) {
      console.error("Error sending transactional email:", error);
      res.status(500).json({ error: "Fout bij verzenden e-mail" });
    }
  });
  app2.post("/api/messages/composer/send", authMiddleware, async (req, res) => {
    try {
      if (req.user.role === "MEDEWERKER") {
        return res.status(403).json({ error: "Geen toegang" });
      }
      const { recipients, subject, content } = req.body;
      if (!recipients || !Array.isArray(recipients) || recipients.length === 0) {
        return res.status(400).json({ error: "Geadresseerden zijn vereist" });
      }
      if (!subject || !content) {
        return res.status(400).json({ error: "Onderwerp en inhoud zijn vereist" });
      }
      let totalRecipients = 0;
      const results = [];
      for (const recipient of recipients) {
        if (recipient.type === "member") {
          try {
            const context = await emailService.buildMemberContext(req.user.tenantId, recipient.value);
            const tempTemplate = {
              subject,
              body_html: emailService.convertToHTML(content),
              body_text: content
            };
            const rendered = await emailService.renderTemplate(tempTemplate, context);
            await emailService.transporter.sendMail({
              from: process.env.SMTP_FROM,
              to: context.member.email,
              subject: rendered.subject,
              html: rendered.html,
              text: rendered.text
            });
            totalRecipients++;
            results.push({ type: "member", recipient: context.member.email, status: "sent" });
          } catch (error) {
            console.error("Error sending to member:", error);
            results.push({ type: "member", recipient: recipient.value, status: "failed", error: error.message });
          }
        } else if (recipient.type === "segment") {
          try {
            const segment = await emailService.getSegment(req.user.tenantId, recipient.value);
            if (segment) {
              const preview = await emailService.previewSegment(req.user.tenantId, segment.rules);
              for (const member of preview.sample) {
                try {
                  const context = await emailService.buildMemberContext(req.user.tenantId, member.id);
                  const tempTemplate = {
                    subject,
                    body_html: emailService.convertToHTML(content),
                    body_text: content
                  };
                  const rendered = await emailService.renderTemplate(tempTemplate, context);
                  await emailService.transporter.sendMail({
                    from: process.env.SMTP_FROM,
                    to: context.member.email,
                    subject: rendered.subject,
                    html: rendered.html,
                    text: rendered.text
                  });
                  totalRecipients++;
                  results.push({ type: "segment", recipient: context.member.email, status: "sent" });
                } catch (error) {
                  console.error("Error sending to segment member:", error);
                  results.push({ type: "segment", recipient: member.email, status: "failed", error: error.message });
                }
              }
            }
          } catch (error) {
            console.error("Error processing segment:", error);
            results.push({ type: "segment", recipient: recipient.value, status: "failed", error: error.message });
          }
        } else if (recipient.type === "email") {
          try {
            const context = {
              member: { firstName: "Geachte", lastName: "heer/mevrouw", email: recipient.value },
              tenant: { name: "Organisatie" },
              card: { url: "#" },
              fees: []
            };
            const tempTemplate = {
              subject,
              body_html: emailService.convertToHTML(content),
              body_text: content
            };
            const rendered = await emailService.renderTemplate(tempTemplate, context);
            await emailService.transporter.sendMail({
              from: process.env.SMTP_FROM,
              to: recipient.value,
              subject: rendered.subject,
              html: rendered.html,
              text: rendered.text
            });
            totalRecipients++;
            results.push({ type: "email", recipient: recipient.value, status: "sent" });
          } catch (error) {
            console.error("Error sending to email:", error);
            results.push({ type: "email", recipient: recipient.value, status: "failed", error: error.message });
          }
        }
      }
      res.json({
        message: `E-mail verzonden naar ${totalRecipients} geadresseerd(en)`,
        totalRecipients,
        results
      });
    } catch (error) {
      console.error("Error sending composer email:", error);
      res.status(500).json({ error: "Fout bij verzenden e-mail" });
    }
  });
  app2.get("/email/unsubscribe", async (req, res) => {
    try {
      const token = req.query.token;
      res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Uitschrijven</title>
          <meta charset="utf-8">
          <style>
            body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }
            .container { text-align: center; }
            .success { color: #10b981; }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>Uitschrijven</h1>
            <p class="success">Je bent succesvol uitgeschreven van marketing e-mails.</p>
            <p>Je ontvangt nog steeds belangrijke transactionele berichten zoals betalingsherinneringen.</p>
          </div>
        </body>
        </html>
      `);
    } catch (error) {
      res.status(500).send("Er is een fout opgetreden");
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use("/uploads", express2.static(path3.join(process.cwd(), "uploads")));
app.use((req, res, next) => {
  const start = Date.now();
  const path4 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path4.startsWith("/api")) {
      let logLine = `${req.method} ${path4} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();